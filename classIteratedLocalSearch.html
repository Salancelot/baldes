<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BALDES: IteratedLocalSearch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BALDES
   </div>
   <div id="projectbrief">Bucket Graph Labeling Algorithm for Vehicle Routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classIteratedLocalSearch.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classIteratedLocalSearch-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IteratedLocalSearch Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RIH_8h_source.html">RIH.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for IteratedLocalSearch:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch__coll__graph.png" border="0" usemap="#aIteratedLocalSearch_coll__map" alt="Collaboration graph"/></div>
<map name="aIteratedLocalSearch_coll__map" id="aIteratedLocalSearch_coll__map">
<area shape="rect" title=" " alt="" coords="5,94,144,120"/>
<area shape="rect" href="structInstanceData.html" title="A structure to hold various data related to an instance of a problem." alt="" coords="25,5,124,31"/>
<area shape="poly" title=" " alt="" coords="77,47,77,94,72,94,72,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5139ace2f7924ec0838aadf2051d6533" id="r_a5139ace2f7924ec0838aadf2051d6533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5139ace2f7924ec0838aadf2051d6533">IteratedLocalSearch</a> (const <a class="el" href="structInstanceData.html">InstanceData</a> &amp;<a class="el" href="#a75465311932a906c7e891d960af07f3a">instance</a>)</td></tr>
<tr class="separator:a5139ace2f7924ec0838aadf2051d6533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70949ea61506794989cb862e25db7349" id="r_a70949ea61506794989cb862e25db7349"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70949ea61506794989cb862e25db7349">relocate_star</a> (const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int i, int j)</td></tr>
<tr class="memdesc:a70949ea61506794989cb862e25db7349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocates a customer from one route to another.  <br /></td></tr>
<tr class="separator:a70949ea61506794989cb862e25db7349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da970485de4e42d2101541b9bb7fe41" id="r_a4da970485de4e42d2101541b9bb7fe41"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4da970485de4e42d2101541b9bb7fe41">enhanced_swap</a> (const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int i, int j)</td></tr>
<tr class="memdesc:a4da970485de4e42d2101541b9bb7fe41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps segments of varying lengths between two routes.  <br /></td></tr>
<tr class="separator:a4da970485de4e42d2101541b9bb7fe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00379a118f576c2aa5449b39fe6d9b5" id="r_af00379a118f576c2aa5449b39fe6d9b5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af00379a118f576c2aa5449b39fe6d9b5">cross</a> (const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int k, int l)</td></tr>
<tr class="memdesc:af00379a118f576c2aa5449b39fe6d9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a crossover operation between two routes at specified positions.  <br /></td></tr>
<tr class="separator:af00379a118f576c2aa5449b39fe6d9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7a1d8bdbc250ee2ff08669b1628ca2" id="r_adc7a1d8bdbc250ee2ff08669b1628ca2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc7a1d8bdbc250ee2ff08669b1628ca2">insertion</a> (const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int k, int l)</td></tr>
<tr class="memdesc:adc7a1d8bdbc250ee2ff08669b1628ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a customer from one route into another route at specified positions.  <br /></td></tr>
<tr class="separator:adc7a1d8bdbc250ee2ff08669b1628ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e65f346f0dc987f086fcb637799f944" id="r_a3e65f346f0dc987f086fcb637799f944"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e65f346f0dc987f086fcb637799f944">swap</a> (const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int k, int l)</td></tr>
<tr class="memdesc:a3e65f346f0dc987f086fcb637799f944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps customers between two routes at specified positions.  <br /></td></tr>
<tr class="separator:a3e65f346f0dc987f086fcb637799f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a259d029276f03fec1f27da9fa6f5dd" id="r_a5a259d029276f03fec1f27da9fa6f5dd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a259d029276f03fec1f27da9fa6f5dd">extended_swap_star</a> (const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int i, int j, int chain_length=2)</td></tr>
<tr class="memdesc:a5a259d029276f03fec1f27da9fa6f5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps sequences of customers between two routes and inserts them at optimal positions.  <br /></td></tr>
<tr class="separator:a5a259d029276f03fec1f27da9fa6f5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84340bf866420ced5900f6852b8007d6" id="r_a84340bf866420ced5900f6852b8007d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84340bf866420ced5900f6852b8007d6">find_best_insertion_position</a> (const std::vector&lt; int &gt; &amp;route, const std::vector&lt; int &gt; &amp;chain)</td></tr>
<tr class="memdesc:a84340bf866420ced5900f6852b8007d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best position to insert a chain of customers into a route.  <br /></td></tr>
<tr class="separator:a84340bf866420ced5900f6852b8007d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3091e48a7a382086b4f9e66b1c2f557" id="r_ad3091e48a7a382086b4f9e66b1c2f557"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3091e48a7a382086b4f9e66b1c2f557">extended_relocate_star</a> (const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int i, int j, int chain_length=2)</td></tr>
<tr class="memdesc:ad3091e48a7a382086b4f9e66b1c2f557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocates a sequence of customers from one route to another.  <br /></td></tr>
<tr class="separator:ad3091e48a7a382086b4f9e66b1c2f557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0537178b1dabf661440b847b8b87f7e8" id="r_a0537178b1dabf661440b847b8b87f7e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0537178b1dabf661440b847b8b87f7e8">select_operator</a> (<a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a> &amp;rng)</td></tr>
<tr class="separator:a0537178b1dabf661440b847b8b87f7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a698c89ab29f98c62a2da7a86fe79" id="r_a1d2a698c89ab29f98c62a2da7a86fe79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d2a698c89ab29f98c62a2da7a86fe79">update_operator_weights</a> ()</td></tr>
<tr class="separator:a1d2a698c89ab29f98c62a2da7a86fe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f7fdcff72c3dcf0895c0010da67e97" id="r_a74f7fdcff72c3dcf0895c0010da67e97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74f7fdcff72c3dcf0895c0010da67e97">perturbation</a> (const std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; &amp;paths, const std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt; &amp;<a class="el" href="#a9a118a2adc98188629ff83420b7af441">nodes</a>)</td></tr>
<tr class="separator:a74f7fdcff72c3dcf0895c0010da67e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a723b31029f70557ff7b378f46e851ee5" id="r_a723b31029f70557ff7b378f46e851ee5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a723b31029f70557ff7b378f46e851ee5">two_opt</a> (const std::vector&lt; int &gt; &amp;route, int i, int j)</td></tr>
<tr class="memdesc:a723b31029f70557ff7b378f46e851ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-opt optimization on a given route.  <br /></td></tr>
<tr class="separator:a723b31029f70557ff7b378f46e851ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a75465311932a906c7e891d960af07f3a" id="r_a75465311932a906c7e891d960af07f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInstanceData.html">InstanceData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75465311932a906c7e891d960af07f3a">instance</a></td></tr>
<tr class="separator:a75465311932a906c7e891d960af07f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a118a2adc98188629ff83420b7af441" id="r_a9a118a2adc98188629ff83420b7af441"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a118a2adc98188629ff83420b7af441">nodes</a></td></tr>
<tr class="separator:a9a118a2adc98188629ff83420b7af441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fafc23d232bee0a9e0c7b7731cb5ca" id="r_ae7fafc23d232bee0a9e0c7b7731cb5ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;(const std::vector&lt; int &gt; &amp;, const std::vector&lt; int &gt; &amp;, int, int)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7fafc23d232bee0a9e0c7b7731cb5ca">operators</a></td></tr>
<tr class="separator:ae7fafc23d232bee0a9e0c7b7731cb5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e98e0d60a2fb80776aaaeec403b1a4" id="r_a84e98e0d60a2fb80776aaaeec403b1a4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a> = {1.0, 1.0, 1.0}</td></tr>
<tr class="separator:a84e98e0d60a2fb80776aaaeec403b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b380a567901e7c9295dbaca6f87218" id="r_a38b380a567901e7c9295dbaca6f87218"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a> = {0.0, 0.0, 0.0}</td></tr>
<tr class="separator:a38b380a567901e7c9295dbaca6f87218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a79b16f83e5f0809583b1be374af6b" id="r_a82a79b16f83e5f0809583b1be374af6b"><td class="memItemLeft" align="right" valign="top">exec::static_thread_pool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a79b16f83e5f0809583b1be374af6b">pool</a> = exec::static_thread_pool(5)</td></tr>
<tr class="separator:a82a79b16f83e5f0809583b1be374af6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473972fc44e0c9dfefe3a04f5cb4f792" id="r_a473972fc44e0c9dfefe3a04f5cb4f792"><td class="memItemLeft" align="right" valign="top">exec::static_thread_pool::scheduler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a473972fc44e0c9dfefe3a04f5cb4f792">sched</a> = pool.get_scheduler()</td></tr>
<tr class="separator:a473972fc44e0c9dfefe3a04f5cb4f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00017">17</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5139ace2f7924ec0838aadf2051d6533" name="a5139ace2f7924ec0838aadf2051d6533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5139ace2f7924ec0838aadf2051d6533">&#9670;&#160;</a></span>IteratedLocalSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratedLocalSearch::IteratedLocalSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structInstanceData.html">InstanceData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00022">22</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   22</span>: <a class="code hl_variable" href="#a75465311932a906c7e891d960af07f3a">instance</a>(<a class="code hl_variable" href="#a75465311932a906c7e891d960af07f3a">instance</a>) {}</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a75465311932a906c7e891d960af07f3a"><div class="ttname"><a href="#a75465311932a906c7e891d960af07f3a">IteratedLocalSearch::instance</a></div><div class="ttdeci">InstanceData instance</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00019">RIH.h:19</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af00379a118f576c2aa5449b39fe6d9b5" name="af00379a118f576c2aa5449b39fe6d9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00379a118f576c2aa5449b39fe6d9b5">&#9670;&#160;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; IteratedLocalSearch::cross </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a crossover operation between two routes at specified positions. </p>
<p>This function takes two routes and two crossover points, and swaps the tails of the routes after the specified positions. The depots (first and last elements) are not allowed to be crossover points. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00103">103</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  104</span>                                                                      {</div>
<div class="line"><span class="lineno">  105</span>        <span class="comment">// Ensure we don&#39;t cross depots (first and last elements)</span></div>
<div class="line"><span class="lineno">  106</span>        <span class="keywordflow">if</span> (k == 0 || k == route1.size() - 1 || l == 0 || l == route2.size() - 1) {</div>
<div class="line"><span class="lineno">  107</span>            <span class="keywordflow">return</span> {route1, route2}; <span class="comment">// No changes if depots are selected</span></div>
<div class="line"><span class="lineno">  108</span>        }</div>
<div class="line"><span class="lineno">  109</span> </div>
<div class="line"><span class="lineno">  110</span>        <span class="comment">// Swap the tails of the routes after position k and l</span></div>
<div class="line"><span class="lineno">  111</span>        std::vector&lt;int&gt; new_route1(route1.begin(), route1.begin() + k);</div>
<div class="line"><span class="lineno">  112</span>        new_route1.insert(new_route1.end(), route2.begin() + l, route2.end());</div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span>        std::vector&lt;int&gt; new_route2(route2.begin(), route2.begin() + l);</div>
<div class="line"><span class="lineno">  115</span>        new_route2.insert(new_route2.end(), route1.begin() + k, route1.end());</div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  118</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4da970485de4e42d2101541b9bb7fe41" name="a4da970485de4e42d2101541b9bb7fe41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da970485de4e42d2101541b9bb7fe41">&#9670;&#160;</a></span>enhanced_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; IteratedLocalSearch::enhanced_swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps segments of varying lengths between two routes. </p>
<p>This function takes two routes and swaps segments of up to 3 elements between them, starting at specified indices. If the start index is at the beginning or end of a route, no changes are made to avoid swapping depot nodes. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00078">78</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   79</span>                                                                                                            {</div>
<div class="line"><span class="lineno">   80</span>        <span class="comment">// Swap segments of varying lengths between two routes</span></div>
<div class="line"><span class="lineno">   81</span>        <span class="keywordflow">if</span> (i == 0 || i == route1.size() - 1 || j == 0 || j == route2.size() - 1) {</div>
<div class="line"><span class="lineno">   82</span>            <span class="keywordflow">return</span> {route1, route2}; <span class="comment">// No changes if depots are selected</span></div>
<div class="line"><span class="lineno">   83</span>        }</div>
<div class="line"><span class="lineno">   84</span> </div>
<div class="line"><span class="lineno">   85</span>        <span class="comment">// Determine segment length to swap</span></div>
<div class="line"><span class="lineno">   86</span>        <span class="keywordtype">int</span>              segment_length = std::min(3, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::min(route1.size() - i, route2.size() - j)));</div>
<div class="line"><span class="lineno">   87</span>        std::vector&lt;int&gt; new_route1(route1);</div>
<div class="line"><span class="lineno">   88</span>        std::vector&lt;int&gt; new_route2(route2);</div>
<div class="line"><span class="lineno">   89</span> </div>
<div class="line"><span class="lineno">   90</span>        std::swap_ranges(new_route1.begin() + i, new_route1.begin() + i + segment_length, new_route2.begin() + j);</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">   93</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3091e48a7a382086b4f9e66b1c2f557" name="ad3091e48a7a382086b4f9e66b1c2f557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3091e48a7a382086b4f9e66b1c2f557">&#9670;&#160;</a></span>extended_relocate_star()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; IteratedLocalSearch::extended_relocate_star </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>chain_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relocates a sequence of customers from one route to another. </p>
<p>This operator moves a chain of 2 or 3 consecutive customers from one route to another. The depots (first and last elements) are not involved. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00240">240</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  242</span>                                                                                               {</div>
<div class="line"><span class="lineno">  243</span>        <span class="comment">// Ensure we are not relocating depot nodes or exceeding bounds</span></div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">if</span> (i == 0 || i + chain_length &gt; route1.size() - 1 || j == 0 || j == route2.size() - 1) {</div>
<div class="line"><span class="lineno">  245</span>            <span class="keywordflow">return</span> {route1, route2}; <span class="comment">// No changes if depots or out-of-bound indices are involved</span></div>
<div class="line"><span class="lineno">  246</span>        }</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span>        <span class="comment">// Relocate a chain of customers from route1 to route2</span></div>
<div class="line"><span class="lineno">  249</span>        std::vector&lt;int&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">  250</span>        std::vector&lt;int&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span>        <span class="comment">// Extract the chain of customers to relocate</span></div>
<div class="line"><span class="lineno">  253</span>        std::vector&lt;int&gt; chain(new_route1.begin() + i, new_route1.begin() + i + chain_length);</div>
<div class="line"><span class="lineno">  254</span> </div>
<div class="line"><span class="lineno">  255</span>        <span class="comment">// Remove the chain from route1</span></div>
<div class="line"><span class="lineno">  256</span>        new_route1.erase(new_route1.begin() + i, new_route1.begin() + i + chain_length);</div>
<div class="line"><span class="lineno">  257</span> </div>
<div class="line"><span class="lineno">  258</span>        <span class="comment">// Insert the chain into route2 at position j</span></div>
<div class="line"><span class="lineno">  259</span>        new_route2.insert(new_route2.begin() + j, chain.begin(), chain.end());</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  262</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a259d029276f03fec1f27da9fa6f5dd" name="a5a259d029276f03fec1f27da9fa6f5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a259d029276f03fec1f27da9fa6f5dd">&#9670;&#160;</a></span>extended_swap_star()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; IteratedLocalSearch::extended_swap_star </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>chain_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps sequences of customers between two routes and inserts them at optimal positions. </p>
<p>This operator swaps a chain of 2 or 3 consecutive customers between two routes, and inserts each chain into the best possible position in the opposite route, ensuring depots are not involved. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00178">178</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  180</span>                                                                                           {</div>
<div class="line"><span class="lineno">  181</span>        <span class="comment">// Ensure we are not swapping depot nodes or exceeding bounds</span></div>
<div class="line"><span class="lineno">  182</span>        <span class="keywordflow">if</span> (i == 0 || i + chain_length &gt; route1.size() - 1 || j == 0 || j + chain_length &gt; route2.size() - 1) {</div>
<div class="line"><span class="lineno">  183</span>            <span class="keywordflow">return</span> {route1, route2}; <span class="comment">// No changes if depots or out-of-bound indices are involved</span></div>
<div class="line"><span class="lineno">  184</span>        }</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>        <span class="comment">// Swap a chain of customers between route1 and route2</span></div>
<div class="line"><span class="lineno">  187</span>        std::vector&lt;int&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">  188</span>        std::vector&lt;int&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="line"><span class="lineno">  190</span>        <span class="comment">// Extract the chains of customers</span></div>
<div class="line"><span class="lineno">  191</span>        std::vector&lt;int&gt; chain1(new_route1.begin() + i, new_route1.begin() + i + chain_length);</div>
<div class="line"><span class="lineno">  192</span>        std::vector&lt;int&gt; chain2(new_route2.begin() + j, new_route2.begin() + j + chain_length);</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>        <span class="comment">// Remove the chains from their respective routes</span></div>
<div class="line"><span class="lineno">  195</span>        new_route1.erase(new_route1.begin() + i, new_route1.begin() + i + chain_length);</div>
<div class="line"><span class="lineno">  196</span>        new_route2.erase(new_route2.begin() + j, new_route2.begin() + j + chain_length);</div>
<div class="line"><span class="lineno">  197</span> </div>
<div class="line"><span class="lineno">  198</span>        <span class="comment">// Insert the chains at the best positions in the opposite routes</span></div>
<div class="line"><span class="lineno">  199</span>        <span class="keyword">auto</span> best_pos_route1 = <a class="code hl_function" href="#a84340bf866420ced5900f6852b8007d6">find_best_insertion_position</a>(new_route1, chain2);</div>
<div class="line"><span class="lineno">  200</span>        <span class="keyword">auto</span> best_pos_route2 = <a class="code hl_function" href="#a84340bf866420ced5900f6852b8007d6">find_best_insertion_position</a>(new_route2, chain1);</div>
<div class="line"><span class="lineno">  201</span> </div>
<div class="line"><span class="lineno">  202</span>        new_route1.insert(new_route1.begin() + best_pos_route1, chain2.begin(), chain2.end());</div>
<div class="line"><span class="lineno">  203</span>        new_route2.insert(new_route2.begin() + best_pos_route2, chain1.begin(), chain1.end());</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  206</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a84340bf866420ced5900f6852b8007d6"><div class="ttname"><a href="#a84340bf866420ced5900f6852b8007d6">IteratedLocalSearch::find_best_insertion_position</a></div><div class="ttdeci">int find_best_insertion_position(const std::vector&lt; int &gt; &amp;route, const std::vector&lt; int &gt; &amp;chain)</div><div class="ttdoc">Finds the best position to insert a chain of customers into a route.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00214">RIH.h:214</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch_a5a259d029276f03fec1f27da9fa6f5dd_cgraph.png" border="0" usemap="#aclassIteratedLocalSearch_a5a259d029276f03fec1f27da9fa6f5dd_cgraph" alt=""/></div>
<map name="aclassIteratedLocalSearch_a5a259d029276f03fec1f27da9fa6f5dd_cgraph" id="aclassIteratedLocalSearch_a5a259d029276f03fec1f27da9fa6f5dd_cgraph">
<area shape="rect" title="Swaps sequences of customers between two routes and inserts them at optimal positions." alt="" coords="5,13,152,54"/>
<area shape="rect" href="classIteratedLocalSearch.html#a84340bf866420ced5900f6852b8007d6" title="Finds the best position to insert a chain of customers into a route." alt="" coords="200,5,338,61"/>
<area shape="poly" title=" " alt="" coords="152,30,184,30,184,36,152,36"/>
</map>
</div>

</div>
</div>
<a id="a84340bf866420ced5900f6852b8007d6" name="a84340bf866420ced5900f6852b8007d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84340bf866420ced5900f6852b8007d6">&#9670;&#160;</a></span>find_best_insertion_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IteratedLocalSearch::find_best_insertion_position </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>chain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the best position to insert a chain of customers into a route. </p>
<p>This helper function evaluates the cost of inserting a chain into each possible position in the route and returns the index of the best insertion point. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00214">214</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  214</span>                                                                                               {</div>
<div class="line"><span class="lineno">  215</span>        <span class="keywordtype">int</span>    best_pos  = 1;</div>
<div class="line"><span class="lineno">  216</span>        <span class="keywordtype">double</span> best_cost = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"><span class="lineno">  217</span> </div>
<div class="line"><span class="lineno">  218</span>        <span class="comment">// Iterate over each possible insertion point (ignoring depot nodes)</span></div>
<div class="line"><span class="lineno">  219</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pos = 1; pos &lt; route.size(); ++pos) {</div>
<div class="line"><span class="lineno">  220</span>            std::vector&lt;int&gt; new_route = route;</div>
<div class="line"><span class="lineno">  221</span>            new_route.insert(new_route.begin() + pos, chain.begin(), chain.end());</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span>            <span class="comment">// Compute the cost of this insertion</span></div>
<div class="line"><span class="lineno">  224</span>            <span class="keywordtype">double</span> cost = this-&gt;compute_cost(new_route).second;</div>
<div class="line"><span class="lineno">  225</span> </div>
<div class="line"><span class="lineno">  226</span>            <span class="keywordflow">if</span> (cost &lt; best_cost) {</div>
<div class="line"><span class="lineno">  227</span>                best_cost = cost;</div>
<div class="line"><span class="lineno">  228</span>                best_pos  = pos;</div>
<div class="line"><span class="lineno">  229</span>            }</div>
<div class="line"><span class="lineno">  230</span>        }</div>
<div class="line"><span class="lineno">  231</span>        <span class="keywordflow">return</span> best_pos;</div>
<div class="line"><span class="lineno">  232</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adc7a1d8bdbc250ee2ff08669b1628ca2" name="adc7a1d8bdbc250ee2ff08669b1628ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7a1d8bdbc250ee2ff08669b1628ca2">&#9670;&#160;</a></span>insertion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; IteratedLocalSearch::insertion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a customer from one route into another route at specified positions. </p>
<p>This function takes two routes and inserts a customer from the first route at position <code>k</code> into the second route at position <code>l</code>. It ensures that depots (first and last positions) are not involved in the insertion process. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00128">128</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  129</span>                                                                                                        {</div>
<div class="line"><span class="lineno">  130</span>        <span class="comment">// Ensure we are not moving or inserting into depots</span></div>
<div class="line"><span class="lineno">  131</span>        <span class="keywordflow">if</span> (k == 0 || k == route1.size() - 1 || l == 0 || l == route2.size() - 1) {</div>
<div class="line"><span class="lineno">  132</span>            <span class="keywordflow">return</span> {route1, route2}; <span class="comment">// No changes if depots are involved</span></div>
<div class="line"><span class="lineno">  133</span>        }</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>        <span class="comment">// Insert customer from route1 at position k into route2 at position l</span></div>
<div class="line"><span class="lineno">  136</span>        std::vector&lt;int&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">  137</span>        std::vector&lt;int&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">  138</span> </div>
<div class="line"><span class="lineno">  139</span>        <span class="keywordflow">if</span> (k &lt; route1.size()) {</div>
<div class="line"><span class="lineno">  140</span>            <span class="keywordtype">int</span> customer = route1[k];</div>
<div class="line"><span class="lineno">  141</span>            new_route1.erase(new_route1.begin() + k);</div>
<div class="line"><span class="lineno">  142</span>            new_route2.insert(new_route2.begin() + l, customer);</div>
<div class="line"><span class="lineno">  143</span>        }</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  146</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74f7fdcff72c3dcf0895c0010da67e97" name="a74f7fdcff72c3dcf0895c0010da67e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f7fdcff72c3dcf0895c0010da67e97">&#9670;&#160;</a></span>perturbation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; IteratedLocalSearch::perturbation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00316">316</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  316</span>                                                                                                      {</div>
<div class="line"><span class="lineno">  317</span>        this-&gt;<a class="code hl_variable" href="#a9a118a2adc98188629ff83420b7af441">nodes</a>               = <a class="code hl_variable" href="#a9a118a2adc98188629ff83420b7af441">nodes</a>;</div>
<div class="line"><span class="lineno">  318</span>        std::vector&lt;Label *&gt; best = paths;</div>
<div class="line"><span class="lineno">  319</span>        std::vector&lt;Label *&gt; best_new;</div>
<div class="line"><span class="lineno">  320</span>        <a class="code hl_class" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a>     rng; <span class="comment">// Instantiate the custom RNG with default seed</span></div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordtype">bool</span>                 is_stuck = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>        std::vector&lt;double&gt; best_costs(paths.size(), std::numeric_limits&lt;double&gt;::max());</div>
<div class="line"><span class="lineno">  324</span> </div>
<div class="line"><span class="lineno">  325</span>        <span class="comment">// Store tasks for parallel processing</span></div>
<div class="line"><span class="lineno">  326</span>        std::vector&lt;std::tuple&lt;const Label *, const Label *, size_t, size_t&gt;&gt; tasks;</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_struct" href="structLabel.html">Label</a> *label_i : best) {</div>
<div class="line"><span class="lineno">  329</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_struct" href="structLabel.html">Label</a> *label_j : best) {</div>
<div class="line"><span class="lineno">  330</span>                <span class="keywordflow">if</span> (label_i == label_j) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  331</span>                <span class="keyword">const</span> <span class="keyword">auto</span> &amp;route_i = label_i-&gt;nodes_covered;</div>
<div class="line"><span class="lineno">  332</span>                <span class="keyword">const</span> <span class="keyword">auto</span> &amp;route_j = label_j-&gt;nodes_covered;</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>                <span class="keywordflow">if</span> (route_i.size() &lt; 3 || route_j.size() &lt; 3) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  335</span> </div>
<div class="line"><span class="lineno">  336</span>                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 1; k &lt; route_i.size() - 1; ++k) {</div>
<div class="line"><span class="lineno">  337</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> l = 1; l &lt; route_j.size() - 1; ++l) { tasks.emplace_back(label_i, label_j, k, l); }</div>
<div class="line"><span class="lineno">  338</span>                }</div>
<div class="line"><span class="lineno">  339</span>            }</div>
<div class="line"><span class="lineno">  340</span>        }</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>        <span class="comment">// Parallelize the task processing</span></div>
<div class="line"><span class="lineno">  343</span>        std::mutex best_new_mutex; <span class="comment">// Mutex to protect access to best_new and operator_improvements</span></div>
<div class="line"><span class="lineno">  344</span>        std::mutex operator_mutex; <span class="comment">// Mutex to protect operator improvements</span></div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>        <span class="comment">// Define chunk size to balance load</span></div>
<div class="line"><span class="lineno">  347</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> chunk_size = 1; <span class="comment">// Adjust chunk size based on performance experiments</span></div>
<div class="line"><span class="lineno">  348</span> </div>
<div class="line"><span class="lineno">  349</span>        <span class="comment">// Parallel execution in chunks</span></div>
<div class="line"><span class="lineno">  350</span>        <span class="keyword">auto</span> bulk_sender = stdexec::bulk(</div>
<div class="line"><span class="lineno">  351</span>            stdexec::just(), (tasks.size() + chunk_size - 1) / chunk_size,</div>
<div class="line"><span class="lineno">  352</span>            [&amp;best_new, &amp;best_new_mutex, &amp;operator_mutex, &amp;tasks, chunk_size, &amp;rng, <span class="keyword">this</span>](std::size_t chunk_idx) {</div>
<div class="line"><span class="lineno">  353</span>                size_t start_idx = chunk_idx * chunk_size;</div>
<div class="line"><span class="lineno">  354</span>                size_t end_idx   = std::min(start_idx + chunk_size, tasks.size());</div>
<div class="line"><span class="lineno">  355</span> </div>
<div class="line"><span class="lineno">  356</span>                for (size_t task_idx = start_idx; task_idx &lt; end_idx; ++task_idx) {</div>
<div class="line"><span class="lineno">  357</span>                    const auto &amp;[label_i, label_j, k, l] = tasks[task_idx];</div>
<div class="line"><span class="lineno">  358</span>                    const auto &amp;route_i                  = label_i-&gt;nodes_covered;</div>
<div class="line"><span class="lineno">  359</span>                    const auto &amp;route_j                  = label_j-&gt;nodes_covered;</div>
<div class="line"><span class="lineno">  360</span> </div>
<div class="line"><span class="lineno">  361</span>                    int op_idx                      = select_operator(rng); <span class="comment">// Select operator based on weights</span></div>
<div class="line"><span class="lineno">  362</span>                    auto [new_route_i, new_route_j] = operators[op_idx](route_i, route_j, k, l);</div>
<div class="line"><span class="lineno">  363</span>                    if (new_route_i.empty() || new_route_j.empty()) continue;</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>                    auto cost_i     = compute_cost(new_route_i);</div>
<div class="line"><span class="lineno">  366</span>                    auto cost_j     = compute_cost(new_route_j);</div>
<div class="line"><span class="lineno">  367</span>                    Path new_path_i = Path{new_route_i, cost_i.first};</div>
<div class="line"><span class="lineno">  368</span>                    Path new_path_j = Path{new_route_j, cost_j.first};</div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>                    if (is_feasible(new_path_i) &amp;&amp; is_feasible(new_path_j)) {</div>
<div class="line"><span class="lineno">  371</span>                        double new_cost     = cost_i.second + cost_j.second;</div>
<div class="line"><span class="lineno">  372</span>                        double current_cost = label_i-&gt;cost + label_j-&gt;cost;</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>                        if (new_cost &lt; current_cost) {</div>
<div class="line"><span class="lineno">  375</span>                            <span class="comment">// Lock to update operator performance and best_new</span></div>
<div class="line"><span class="lineno">  376</span>                            {</div>
<div class="line"><span class="lineno">  377</span>                                std::lock_guard&lt;std::mutex&gt; lock(operator_mutex);</div>
<div class="line"><span class="lineno">  378</span>                                operator_improvements[op_idx] += current_cost - new_cost;</div>
<div class="line"><span class="lineno">  379</span>                            }</div>
<div class="line"><span class="lineno">  380</span> </div>
<div class="line"><span class="lineno">  381</span>                            auto best_new_i_label           = new Label();</div>
<div class="line"><span class="lineno">  382</span>                            best_new_i_label-&gt;nodes_covered = new_path_i.route;</div>
<div class="line"><span class="lineno">  383</span>                            best_new_i_label-&gt;real_cost     = cost_i.first;</div>
<div class="line"><span class="lineno">  384</span>                            best_new_i_label-&gt;cost          = cost_i.second;</div>
<div class="line"><span class="lineno">  385</span> </div>
<div class="line"><span class="lineno">  386</span>                            auto best_new_j_label           = new Label();</div>
<div class="line"><span class="lineno">  387</span>                            best_new_j_label-&gt;nodes_covered = new_path_j.route;</div>
<div class="line"><span class="lineno">  388</span>                            best_new_j_label-&gt;real_cost     = cost_j.first;</div>
<div class="line"><span class="lineno">  389</span>                            best_new_j_label-&gt;cost          = cost_j.second;</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span>                            {</div>
<div class="line"><span class="lineno">  392</span>                                std::lock_guard&lt;std::mutex&gt; lock(best_new_mutex);</div>
<div class="line"><span class="lineno">  393</span>                                best_new.push_back(best_new_i_label);</div>
<div class="line"><span class="lineno">  394</span>                                best_new.push_back(best_new_j_label);</div>
<div class="line"><span class="lineno">  395</span>                            }</div>
<div class="line"><span class="lineno">  396</span>                        }</div>
<div class="line"><span class="lineno">  397</span>                    }</div>
<div class="line"><span class="lineno">  398</span>                }</div>
<div class="line"><span class="lineno">  399</span>            });</div>
<div class="line"><span class="lineno">  400</span> </div>
<div class="line"><span class="lineno">  401</span>        <span class="comment">// Submit work to the thread pool</span></div>
<div class="line"><span class="lineno">  402</span>        <span class="keyword">auto</span> work = stdexec::starts_on(<a class="code hl_variable" href="#a473972fc44e0c9dfefe3a04f5cb4f792">sched</a>, bulk_sender);</div>
<div class="line"><span class="lineno">  403</span>        stdexec::sync_wait(std::move(work));</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>        <span class="comment">// Update operator weights based on performance</span></div>
<div class="line"><span class="lineno">  406</span>        <a class="code hl_function" href="#a1d2a698c89ab29f98c62a2da7a86fe79">update_operator_weights</a>();</div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span>        <span class="comment">// Sort and limit to top solutions</span></div>
<div class="line"><span class="lineno">  409</span>        pdqsort(best_new.begin(), best_new.end(), [](<span class="keyword">const</span> <a class="code hl_struct" href="structLabel.html">Label</a> *a, <span class="keyword">const</span> <a class="code hl_struct" href="structLabel.html">Label</a> *b) { return a-&gt;cost &lt; b-&gt;cost; });</div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">if</span> (best_new.size() &gt; 5) { best_new.erase(best_new.begin() + 5, best_new.end()); }</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span>        <span class="keywordflow">return</span> best_new;</div>
<div class="line"><span class="lineno">  413</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a1d2a698c89ab29f98c62a2da7a86fe79"><div class="ttname"><a href="#a1d2a698c89ab29f98c62a2da7a86fe79">IteratedLocalSearch::update_operator_weights</a></div><div class="ttdeci">void update_operator_weights()</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00303">RIH.h:303</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a473972fc44e0c9dfefe3a04f5cb4f792"><div class="ttname"><a href="#a473972fc44e0c9dfefe3a04f5cb4f792">IteratedLocalSearch::sched</a></div><div class="ttdeci">exec::static_thread_pool::scheduler sched</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00314">RIH.h:314</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a9a118a2adc98188629ff83420b7af441"><div class="ttname"><a href="#a9a118a2adc98188629ff83420b7af441">IteratedLocalSearch::nodes</a></div><div class="ttdeci">std::vector&lt; VRPNode &gt; nodes</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00020">RIH.h:20</a></div></div>
<div class="ttc" id="aclassXoroshiro128Plus_html"><div class="ttname"><a href="classXoroshiro128Plus.html">Xoroshiro128Plus</a></div><div class="ttdef"><b>Definition</b> <a href="RNG_8h_source.html#l00008">RNG.h:8</a></div></div>
<div class="ttc" id="astructLabel_html"><div class="ttname"><a href="structLabel.html">Label</a></div><div class="ttdoc">Represents a label used in a solver.</div><div class="ttdef"><b>Definition</b> <a href="Label_8h_source.html#l00028">Label.h:28</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a70949ea61506794989cb862e25db7349" name="a70949ea61506794989cb862e25db7349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70949ea61506794989cb862e25db7349">&#9670;&#160;</a></span>relocate_star()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; IteratedLocalSearch::relocate_star </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relocates a customer from one route to another. </p>
<p>This function relocates the customer at position <code>i</code> in <code>route1</code> to position <code>j</code> in <code>route2</code>. If the positions <code>i</code> or <code>j</code> involve depots (i.e., the first or last positions in the routes), no changes are made and the original routes are returned. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00053">53</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   54</span>                                                                                                            {</div>
<div class="line"><span class="lineno">   55</span>        <span class="comment">// Relocate customer at position i in route1 to position j in route2</span></div>
<div class="line"><span class="lineno">   56</span>        <span class="keywordflow">if</span> (i == 0 || i == route1.size() - 1 || j == 0 || j == route2.size() - 1) {</div>
<div class="line"><span class="lineno">   57</span>            <span class="keywordflow">return</span> {route1, route2}; <span class="comment">// No changes if depots are involved</span></div>
<div class="line"><span class="lineno">   58</span>        }</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>        std::vector&lt;int&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">   61</span>        std::vector&lt;int&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span>        <span class="keywordtype">int</span> customer = route1[i];</div>
<div class="line"><span class="lineno">   64</span>        new_route1.erase(new_route1.begin() + i);            <span class="comment">// Remove from route1</span></div>
<div class="line"><span class="lineno">   65</span>        new_route2.insert(new_route2.begin() + j, customer); <span class="comment">// Insert into route2</span></div>
<div class="line"><span class="lineno">   66</span> </div>
<div class="line"><span class="lineno">   67</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">   68</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0537178b1dabf661440b847b8b87f7e8" name="a0537178b1dabf661440b847b8b87f7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0537178b1dabf661440b847b8b87f7e8">&#9670;&#160;</a></span>select_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IteratedLocalSearch::select_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rng</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00290">290</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  290</span>                                               {</div>
<div class="line"><span class="lineno">  291</span>        std::vector&lt;double&gt; cumulative_weights(<a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>.size());</div>
<div class="line"><span class="lineno">  292</span>        std::partial_sum(<a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>.begin(), <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>.end(), cumulative_weights.begin());</div>
<div class="line"><span class="lineno">  293</span> </div>
<div class="line"><span class="lineno">  294</span>        <span class="comment">// Generate random number and select operator based on cumulative weights</span></div>
<div class="line"><span class="lineno">  295</span>        <span class="keywordtype">double</span> random_value = (<span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">double</span><span class="keyword">&gt;</span>(rng()) / <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">double</span><span class="keyword">&gt;</span>(<a class="code hl_function" href="classXoroshiro128Plus.html#af711d703a82270ca4aceaf17674a1ade">Xoroshiro128Plus::max</a>())) *</div>
<div class="line"><span class="lineno">  296</span>                              cumulative_weights.back();</div>
<div class="line"><span class="lineno">  297</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; cumulative_weights.size(); ++i) {</div>
<div class="line"><span class="lineno">  298</span>            <span class="keywordflow">if</span> (random_value &lt;= cumulative_weights[i]) { <span class="keywordflow">return</span> i; }</div>
<div class="line"><span class="lineno">  299</span>        }</div>
<div class="line"><span class="lineno">  300</span>        <span class="keywordflow">return</span> cumulative_weights.size() - 1; <span class="comment">// Fallback to the last operator</span></div>
<div class="line"><span class="lineno">  301</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a84e98e0d60a2fb80776aaaeec403b1a4"><div class="ttname"><a href="#a84e98e0d60a2fb80776aaaeec403b1a4">IteratedLocalSearch::operator_weights</a></div><div class="ttdeci">std::vector&lt; double &gt; operator_weights</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00286">RIH.h:286</a></div></div>
<div class="ttc" id="aclassXoroshiro128Plus_html_af711d703a82270ca4aceaf17674a1ade"><div class="ttname"><a href="classXoroshiro128Plus.html#af711d703a82270ca4aceaf17674a1ade">Xoroshiro128Plus::max</a></div><div class="ttdeci">static constexpr result_type max()</div><div class="ttdef"><b>Definition</b> <a href="RNG_8h_source.html#l00035">RNG.h:35</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch_a0537178b1dabf661440b847b8b87f7e8_cgraph.png" border="0" usemap="#aclassIteratedLocalSearch_a0537178b1dabf661440b847b8b87f7e8_cgraph" alt=""/></div>
<map name="aclassIteratedLocalSearch_a0537178b1dabf661440b847b8b87f7e8_cgraph" id="aclassIteratedLocalSearch_a0537178b1dabf661440b847b8b87f7e8_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,144,46"/>
<area shape="rect" href="classXoroshiro128Plus.html#af711d703a82270ca4aceaf17674a1ade" title=" " alt="" coords="192,13,345,38"/>
<area shape="poly" title=" " alt="" coords="144,23,176,23,176,28,144,28"/>
</map>
</div>

</div>
</div>
<a id="a3e65f346f0dc987f086fcb637799f944" name="a3e65f346f0dc987f086fcb637799f944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e65f346f0dc987f086fcb637799f944">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; IteratedLocalSearch::swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps customers between two routes at specified positions. </p>
<p>This function takes two routes and swaps the customers at the specified positions k and l. It ensures that depot positions (first and last elements) are not swapped. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00156">156</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  157</span>                                                                     {</div>
<div class="line"><span class="lineno">  158</span>        <span class="comment">// Ensure we are not swapping depots</span></div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">if</span> (k == 0 || k == route1.size() - 1 || l == 0 || l == route2.size() - 1) {</div>
<div class="line"><span class="lineno">  160</span>            <span class="keywordflow">return</span> {route1, route2}; <span class="comment">// No changes if depots are selected</span></div>
<div class="line"><span class="lineno">  161</span>        }</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>        <span class="comment">// Swap customers between route1 at position k and route2 at position l</span></div>
<div class="line"><span class="lineno">  164</span>        std::vector&lt;int&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">  165</span>        std::vector&lt;int&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>        <span class="keywordflow">if</span> (k &lt; route1.size() &amp;&amp; l &lt; route2.size()) { std::swap(new_route1[k], new_route2[l]); }</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  170</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a723b31029f70557ff7b378f46e851ee5" name="a723b31029f70557ff7b378f46e851ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723b31029f70557ff7b378f46e851ee5">&#9670;&#160;</a></span>two_opt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; int &gt; IteratedLocalSearch::two_opt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the 2-opt optimization on a given route. </p>
<p>This function takes a route and two indices, i and j, and returns a new route where the segment between i and j is reversed. The function ensures that the indices are within bounds and that the depots (first and last elements) are not involved in the reversal. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00033">33</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   33</span>                                                                             {</div>
<div class="line"><span class="lineno">   34</span>        <span class="comment">// Ensure indices are within bounds</span></div>
<div class="line"><span class="lineno">   35</span>        <span class="keywordflow">if</span> (i &gt;= j || i == 0 || j == route.size() - 1) {</div>
<div class="line"><span class="lineno">   36</span>            <span class="keywordflow">return</span> route; <span class="comment">// No changes if depots are involved</span></div>
<div class="line"><span class="lineno">   37</span>        }</div>
<div class="line"><span class="lineno">   38</span> </div>
<div class="line"><span class="lineno">   39</span>        <span class="comment">// Create a new route with the segment between i and j reversed</span></div>
<div class="line"><span class="lineno">   40</span>        std::vector&lt;int&gt; new_route(route);</div>
<div class="line"><span class="lineno">   41</span>        std::reverse(new_route.begin() + i, new_route.begin() + j + 1);</div>
<div class="line"><span class="lineno">   42</span>        <span class="keywordflow">return</span> new_route;</div>
<div class="line"><span class="lineno">   43</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d2a698c89ab29f98c62a2da7a86fe79" name="a1d2a698c89ab29f98c62a2da7a86fe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2a698c89ab29f98c62a2da7a86fe79">&#9670;&#160;</a></span>update_operator_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IteratedLocalSearch::update_operator_weights </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00303">303</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  303</span>                                   {</div>
<div class="line"><span class="lineno">  304</span>        <span class="comment">// Normalize improvements and update weights (use some smoothing factor)</span></div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordtype">double</span> total_improvement = std::accumulate(<a class="code hl_variable" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a>.begin(), <a class="code hl_variable" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a>.end(), 0.0);</div>
<div class="line"><span class="lineno">  306</span>        <span class="keywordflow">if</span> (total_improvement &gt; 0) {</div>
<div class="line"><span class="lineno">  307</span>            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>.size(); ++i) {</div>
<div class="line"><span class="lineno">  308</span>                <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>[i] = 0.9 * <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>[i] + 0.1 * (<a class="code hl_variable" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a>[i] / total_improvement);</div>
<div class="line"><span class="lineno">  309</span>            }</div>
<div class="line"><span class="lineno">  310</span>        }</div>
<div class="line"><span class="lineno">  311</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a38b380a567901e7c9295dbaca6f87218"><div class="ttname"><a href="#a38b380a567901e7c9295dbaca6f87218">IteratedLocalSearch::operator_improvements</a></div><div class="ttdeci">std::vector&lt; double &gt; operator_improvements</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00287">RIH.h:287</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a75465311932a906c7e891d960af07f3a" name="a75465311932a906c7e891d960af07f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75465311932a906c7e891d960af07f3a">&#9670;&#160;</a></span>instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInstanceData.html">InstanceData</a> IteratedLocalSearch::instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00019">19</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a9a118a2adc98188629ff83420b7af441" name="a9a118a2adc98188629ff83420b7af441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a118a2adc98188629ff83420b7af441">&#9670;&#160;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structVRPNode.html">VRPNode</a>&gt; IteratedLocalSearch::nodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00020">20</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a38b380a567901e7c9295dbaca6f87218" name="a38b380a567901e7c9295dbaca6f87218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b380a567901e7c9295dbaca6f87218">&#9670;&#160;</a></span>operator_improvements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IteratedLocalSearch::operator_improvements = {0.0, 0.0, 0.0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00287">287</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  287</span>{0.0, 0.0, 0.0};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a84e98e0d60a2fb80776aaaeec403b1a4" name="a84e98e0d60a2fb80776aaaeec403b1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e98e0d60a2fb80776aaaeec403b1a4">&#9670;&#160;</a></span>operator_weights</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IteratedLocalSearch::operator_weights = {1.0, 1.0, 1.0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00286">286</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  286</span>{1.0, 1.0, 1.0}; <span class="comment">// Start with equal weights</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7fafc23d232bee0a9e0c7b7731cb5ca" name="ae7fafc23d232bee0a9e0c7b7731cb5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fafc23d232bee0a9e0c7b7731cb5ca">&#9670;&#160;</a></span>operators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::function&lt;std::pair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt; &gt;(const std::vector&lt;int&gt; &amp;, const std::vector&lt;int&gt; &amp;, int, int)&gt; &gt; IteratedLocalSearch::operators</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {[<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line">                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#af00379a118f576c2aa5449b39fe6d9b5">cross</a>(route1, route2, k, l);</div>
<div class="line">                     },</div>
<div class="line">                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line">                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#adc7a1d8bdbc250ee2ff08669b1628ca2">insertion</a>(route1, route2, k, l);</div>
<div class="line">                     },</div>
<div class="line">                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line">                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#a3e65f346f0dc987f086fcb637799f944">swap</a>(route1, route2, k, l);</div>
<div class="line">                     },</div>
<div class="line">                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line">                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#a70949ea61506794989cb862e25db7349">relocate_star</a>(route1, route2, k, l);</div>
<div class="line">                     },</div>
<div class="line">                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line">                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#a4da970485de4e42d2101541b9bb7fe41">enhanced_swap</a>(route1, route2, k, l);</div>
<div class="line">                     }}</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a3e65f346f0dc987f086fcb637799f944"><div class="ttname"><a href="#a3e65f346f0dc987f086fcb637799f944">IteratedLocalSearch::swap</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; swap(const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int k, int l)</div><div class="ttdoc">Swaps customers between two routes at specified positions.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00156">RIH.h:156</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a4da970485de4e42d2101541b9bb7fe41"><div class="ttname"><a href="#a4da970485de4e42d2101541b9bb7fe41">IteratedLocalSearch::enhanced_swap</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; enhanced_swap(const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int i, int j)</div><div class="ttdoc">Swaps segments of varying lengths between two routes.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00078">RIH.h:78</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a70949ea61506794989cb862e25db7349"><div class="ttname"><a href="#a70949ea61506794989cb862e25db7349">IteratedLocalSearch::relocate_star</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; relocate_star(const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int i, int j)</div><div class="ttdoc">Relocates a customer from one route to another.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00053">RIH.h:53</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_adc7a1d8bdbc250ee2ff08669b1628ca2"><div class="ttname"><a href="#adc7a1d8bdbc250ee2ff08669b1628ca2">IteratedLocalSearch::insertion</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; insertion(const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int k, int l)</div><div class="ttdoc">Inserts a customer from one route into another route at specified positions.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00128">RIH.h:128</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_af00379a118f576c2aa5449b39fe6d9b5"><div class="ttname"><a href="#af00379a118f576c2aa5449b39fe6d9b5">IteratedLocalSearch::cross</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt; cross(const std::vector&lt; int &gt; &amp;route1, const std::vector&lt; int &gt; &amp;route2, int k, int l)</div><div class="ttdoc">Performs a crossover operation between two routes at specified positions.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00103">RIH.h:103</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00270">270</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  270</span>                    {[<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line"><span class="lineno">  271</span>                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#af00379a118f576c2aa5449b39fe6d9b5">cross</a>(route1, route2, k, l);</div>
<div class="line"><span class="lineno">  272</span>                     },</div>
<div class="line"><span class="lineno">  273</span>                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line"><span class="lineno">  274</span>                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#adc7a1d8bdbc250ee2ff08669b1628ca2">insertion</a>(route1, route2, k, l);</div>
<div class="line"><span class="lineno">  275</span>                     },</div>
<div class="line"><span class="lineno">  276</span>                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line"><span class="lineno">  277</span>                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#a3e65f346f0dc987f086fcb637799f944">swap</a>(route1, route2, k, l);</div>
<div class="line"><span class="lineno">  278</span>                     },</div>
<div class="line"><span class="lineno">  279</span>                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line"><span class="lineno">  280</span>                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#a70949ea61506794989cb862e25db7349">relocate_star</a>(route1, route2, k, l);</div>
<div class="line"><span class="lineno">  281</span>                     },</div>
<div class="line"><span class="lineno">  282</span>                     [<span class="keyword">this</span>](<span class="keyword">const</span> std::vector&lt;int&gt; &amp;route1, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;route2, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line"><span class="lineno">  283</span>                         <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="#a4da970485de4e42d2101541b9bb7fe41">enhanced_swap</a>(route1, route2, k, l);</div>
<div class="line"><span class="lineno">  284</span>                     }};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82a79b16f83e5f0809583b1be374af6b" name="a82a79b16f83e5f0809583b1be374af6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a79b16f83e5f0809583b1be374af6b">&#9670;&#160;</a></span>pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exec::static_thread_pool IteratedLocalSearch::pool = exec::static_thread_pool(5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00313">313</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a473972fc44e0c9dfefe3a04f5cb4f792" name="a473972fc44e0c9dfefe3a04f5cb4f792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473972fc44e0c9dfefe3a04f5cb4f792">&#9670;&#160;</a></span>sched</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exec::static_thread_pool::scheduler IteratedLocalSearch::sched = pool.get_scheduler()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00314">314</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RIH_8h_source.html">RIH.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classIteratedLocalSearch.html">IteratedLocalSearch</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
