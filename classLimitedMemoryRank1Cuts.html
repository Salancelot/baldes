<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BALDES: LimitedMemoryRank1Cuts Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BALDES
   </div>
   <div id="projectbrief">Bucket Graph Labeling Algorithm for Vehicle Routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classLimitedMemoryRank1Cuts.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classLimitedMemoryRank1Cuts-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LimitedMemoryRank1Cuts Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for handling limited memory rank-1 cuts in optimization problems.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SRC_8h_source.html">SRC.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for LimitedMemoryRank1Cuts:</div>
<div class="dyncontent">
<div class="center"><img src="classLimitedMemoryRank1Cuts__coll__graph.png" border="0" usemap="#aLimitedMemoryRank1Cuts_coll__map" alt="Collaboration graph"/></div>
<map name="aLimitedMemoryRank1Cuts_coll__map" id="aLimitedMemoryRank1Cuts_coll__map">
<area shape="rect" title="A class for handling limited memory rank&#45;1 cuts in optimization problems." alt="" coords="44,94,218,120"/>
<area shape="rect" href="classXoroshiro128Plus.html" title=" " alt="" coords="5,5,129,31"/>
<area shape="poly" title=" " alt="" coords="87,42,124,92,120,95,83,45"/>
<area shape="rect" href="classCutStorage.html" title="Manages the storage and operations related to cuts in a solver." alt="" coords="153,5,240,31"/>
<area shape="poly" title=" " alt="" coords="180,45,142,95,138,92,176,42"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLimitedMemoryRank1Cuts_1_1CompareCuts.html">CompareCuts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a70e3c7a88c1c37a3932a959454d298f8" id="r_a70e3c7a88c1c37a3932a959454d298f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70e3c7a88c1c37a3932a959454d298f8">ViolatedCut</a> = std::pair&lt;double, <a class="el" href="structCut.html">Cut</a>&gt;</td></tr>
<tr class="separator:a70e3c7a88c1c37a3932a959454d298f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079bd845ca33bdfc18be9e392626acc0" id="r_a079bd845ca33bdfc18be9e392626acc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a079bd845ca33bdfc18be9e392626acc0">CutPriorityQueue</a> = std::priority_queue&lt;<a class="el" href="#a70e3c7a88c1c37a3932a959454d298f8">ViolatedCut</a>, std::vector&lt;<a class="el" href="#a70e3c7a88c1c37a3932a959454d298f8">ViolatedCut</a>&gt;, <a class="el" href="structLimitedMemoryRank1Cuts_1_1CompareCuts.html">CompareCuts</a>&gt;</td></tr>
<tr class="separator:a079bd845ca33bdfc18be9e392626acc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3689fb1a4c98eeb8f0c4b81f3caaed31" id="r_a3689fb1a4c98eeb8f0c4b81f3caaed31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3689fb1a4c98eeb8f0c4b81f3caaed31">LimitedMemoryRank1Cuts</a> (std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a3689fb1a4c98eeb8f0c4b81f3caaed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79183e6e2d123f4eda657c6aca7e8dd" id="r_aa79183e6e2d123f4eda657c6aca7e8dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa79183e6e2d123f4eda657c6aca7e8dd">LimitedMemoryRank1Cuts</a> ()=default</td></tr>
<tr class="separator:aa79183e6e2d123f4eda657c6aca7e8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97184beb1ff942ca01ffa2ab2bf18f1a" id="r_a97184beb1ff942ca01ffa2ab2bf18f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97184beb1ff942ca01ffa2ab2bf18f1a">printBaseSets</a> ()</td></tr>
<tr class="separator:a97184beb1ff942ca01ffa2ab2bf18f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eb8134a3b061fc6e19ae25f6fa3599" id="r_a34eb8134a3b061fc6e19ae25f6fa3599"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34eb8134a3b061fc6e19ae25f6fa3599">separate</a> (const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;A, const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="memdesc:a34eb8134a3b061fc6e19ae25f6fa3599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates the given solution vector into cuts using Limited Memory Rank-1 Cuts.  <br /></td></tr>
<tr class="separator:a34eb8134a3b061fc6e19ae25f6fa3599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9791c60c60f55c1ce5706e6a2b3574c" id="r_ae9791c60c60f55c1ce5706e6a2b3574c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9791c60c60f55c1ce5706e6a2b3574c">insertSet</a> (<a class="el" href="structVRPTW__SRC.html">VRPTW_SRC</a> &amp;cuts, int i, int j, int k, const std::vector&lt; int &gt; &amp;buffer_int, int buffer_int_n, double LHS_cut)</td></tr>
<tr class="memdesc:ae9791c60c60f55c1ce5706e6a2b3574c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a set of indices and associated data into the <a class="el" href="structVRPTW__SRC.html" title="A structure to represent the Vehicle Routing Problem with Time Windows (VRPTW) source data.">VRPTW_SRC</a> cuts structure.  <br /></td></tr>
<tr class="separator:ae9791c60c60f55c1ce5706e6a2b3574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3630f3c02917789164102d02fc4768" id="r_a6a3630f3c02917789164102d02fc4768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3630f3c02917789164102d02fc4768">generateCutCoefficients</a> (<a class="el" href="structVRPTW__SRC.html">VRPTW_SRC</a> &amp;cuts, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;coefficients, int numNodes, const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;A, const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="memdesc:a6a3630f3c02917789164102d02fc4768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates cut coefficients for the given <a class="el" href="structVRPTW__SRC.html" title="A structure to represent the Vehicle Routing Problem with Time Windows (VRPTW) source data.">VRPTW_SRC</a> cuts.  <br /></td></tr>
<tr class="separator:a6a3630f3c02917789164102d02fc4768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3eba87af98185081086c5f5b34c5ce" id="r_a7b3eba87af98185081086c5f5b34c5ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425f">CutType</a> T&gt; </td></tr>
<tr class="memitem:a7b3eba87af98185081086c5f5b34c5ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b3eba87af98185081086c5f5b34c5ce">the45Heuristic</a> (const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;A, const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="memdesc:a7b3eba87af98185081086c5f5b34c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the 45 Heuristic for generating limited memory rank-1 cuts.  <br /></td></tr>
<tr class="separator:a7b3eba87af98185081086c5f5b34c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5f8095d331b58224e2e36a985aabb8" id="r_a1b5f8095d331b58224e2e36a985aabb8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b5f8095d331b58224e2e36a985aabb8">computeLimitedMemoryCoefficient</a> (const std::array&lt; uint64_t, <a class="el" href="Definitions_8h.html#a38c168723ff0872970a49c6ee54e9bf7">num_words</a> &gt; &amp;C, const std::array&lt; uint64_t, <a class="el" href="Definitions_8h.html#a38c168723ff0872970a49c6ee54e9bf7">num_words</a> &gt; &amp;AM, const <a class="el" href="structSRCPermutation.html">SRCPermutation</a> &amp;p, const std::vector&lt; int &gt; &amp;P, std::vector&lt; int &gt; &amp;order)</td></tr>
<tr class="memdesc:a1b5f8095d331b58224e2e36a985aabb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the limited memory coefficient based on the given parameters.  <br /></td></tr>
<tr class="separator:a1b5f8095d331b58224e2e36a985aabb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f6f1ce5f46f80b1e8840ccd5b0521a" id="r_a29f6f1ce5f46f80b1e8840ccd5b0521a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f6f1ce5f46f80b1e8840ccd5b0521a">selectHighestCoefficients</a> (const std::vector&lt; double &gt; &amp;x, int maxNodes)</td></tr>
<tr class="memdesc:a29f6f1ce5f46f80b1e8840ccd5b0521a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the indices of the highest coefficients from a given vector.  <br /></td></tr>
<tr class="separator:a29f6f1ce5f46f80b1e8840ccd5b0521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5298782f45bc4106a5397a4c0b9705" id="r_a2b5298782f45bc4106a5397a4c0b9705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b5298782f45bc4106a5397a4c0b9705">prepare45Heuristic</a> (const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;A, const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:a2b5298782f45bc4106a5397a4c0b9705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dde5f58774e939e3ce6635cbf9dc91e" id="r_a4dde5f58774e939e3ce6635cbf9dc91e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dde5f58774e939e3ce6635cbf9dc91e">runSeparation</a> (<a class="el" href="classBNBNode.html">BNBNode</a> *node, std::vector&lt; <a class="el" href="classbaldes_1_1Constraint.html">baldes::Constraint</a> * &gt; &amp;SRCconstraints)</td></tr>
<tr class="separator:a4dde5f58774e939e3ce6635cbf9dc91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9ee64e3c2c61461ce2755bfa73f7697b" id="r_a9ee64e3c2c61461ce2755bfa73f7697b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structCachedCut.html">CachedCut</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ee64e3c2c61461ce2755bfa73f7697b">cutCache4</a></td></tr>
<tr class="separator:a9ee64e3c2c61461ce2755bfa73f7697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7540a903f5c7b58271db330f0013d6" id="r_ade7540a903f5c7b58271db330f0013d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structCachedCut.html">CachedCut</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade7540a903f5c7b58271db330f0013d6">cutCache5</a></td></tr>
<tr class="separator:ade7540a903f5c7b58271db330f0013d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad457505a281134f1d458e81305ccac" id="r_a2ad457505a281134f1d458e81305ccac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad457505a281134f1d458e81305ccac">rp</a></td></tr>
<tr class="separator:a2ad457505a281134f1d458e81305ccac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582069540ed19e7a5ec234bd7a0fa4d3" id="r_a582069540ed19e7a5ec234bd7a0fa4d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCutStorage.html">CutStorage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a582069540ed19e7a5ec234bd7a0fa4d3">cutStorage</a> = <a class="el" href="classCutStorage.html">CutStorage</a>()</td></tr>
<tr class="separator:a582069540ed19e7a5ec234bd7a0fa4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad518dd2434c218df7e9283238a6577" id="r_aaad518dd2434c218df7e9283238a6577"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structPath.html">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad518dd2434c218df7e9283238a6577">allPaths</a></td></tr>
<tr class="separator:aaad518dd2434c218df7e9283238a6577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3eac915da287987fb15c33d9cdab99" id="r_a5b3eac915da287987fb15c33d9cdab99"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b3eac915da287987fb15c33d9cdab99">labels</a></td></tr>
<tr class="separator:a5b3eac915da287987fb15c33d9cdab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bcaab96c5a959c0f9ac7a7cea50ff8" id="r_ac5bcaab96c5a959c0f9ac7a7cea50ff8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5bcaab96c5a959c0f9ac7a7cea50ff8">labels_counter</a> = 0</td></tr>
<tr class="separator:ac5bcaab96c5a959c0f9ac7a7cea50ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9fbfe139aabbb019ed099c0b485f5c" id="r_afd9fbfe139aabbb019ed099c0b485f5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd9fbfe139aabbb019ed099c0b485f5c">the45selectedNodes</a></td></tr>
<tr class="separator:afd9fbfe139aabbb019ed099c0b485f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for handling limited memory rank-1 cuts in optimization problems. </p>
<p>This class provides methods for separating cuts by enumeration, generating cut coefficients, and computing limited memory coefficients. It also includes various utility functions for managing and printing base sets, inserting sets, and performing heuristics. </p>

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00087">87</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a079bd845ca33bdfc18be9e392626acc0" name="a079bd845ca33bdfc18be9e392626acc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079bd845ca33bdfc18be9e392626acc0">&#9670;&#160;</a></span>CutPriorityQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a079bd845ca33bdfc18be9e392626acc0">LimitedMemoryRank1Cuts::CutPriorityQueue</a> = std::priority_queue&lt;<a class="el" href="#a70e3c7a88c1c37a3932a959454d298f8">ViolatedCut</a>, std::vector&lt;<a class="el" href="#a70e3c7a88c1c37a3932a959454d298f8">ViolatedCut</a>&gt;, <a class="el" href="structLimitedMemoryRank1Cuts_1_1CompareCuts.html">CompareCuts</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00154">154</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="a70e3c7a88c1c37a3932a959454d298f8" name="a70e3c7a88c1c37a3932a959454d298f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e3c7a88c1c37a3932a959454d298f8">&#9670;&#160;</a></span>ViolatedCut</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a70e3c7a88c1c37a3932a959454d298f8">LimitedMemoryRank1Cuts::ViolatedCut</a> = std::pair&lt;double, <a class="el" href="structCut.html">Cut</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00147">147</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3689fb1a4c98eeb8f0c4b81f3caaed31" name="a3689fb1a4c98eeb8f0c4b81f3caaed31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3689fb1a4c98eeb8f0c4b81f3caaed31">&#9670;&#160;</a></span>LimitedMemoryRank1Cuts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LimitedMemoryRank1Cuts::LimitedMemoryRank1Cuts </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8cpp_source.html#l00106">106</a> of file <a class="el" href="SRC_8cpp_source.html">SRC.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  106</span>: nodes(nodes) {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa79183e6e2d123f4eda657c6aca7e8dd" name="aa79183e6e2d123f4eda657c6aca7e8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79183e6e2d123f4eda657c6aca7e8dd">&#9670;&#160;</a></span>LimitedMemoryRank1Cuts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LimitedMemoryRank1Cuts::LimitedMemoryRank1Cuts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b5f8095d331b58224e2e36a985aabb8" name="a1b5f8095d331b58224e2e36a985aabb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5f8095d331b58224e2e36a985aabb8">&#9670;&#160;</a></span>computeLimitedMemoryCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LimitedMemoryRank1Cuts::computeLimitedMemoryCoefficient </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; uint64_t, <a class="el" href="Definitions_8h.html#a38c168723ff0872970a49c6ee54e9bf7">num_words</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; uint64_t, <a class="el" href="Definitions_8h.html#a38c168723ff0872970a49c6ee54e9bf7">num_words</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>AM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSRCPermutation.html">SRCPermutation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the limited memory coefficient based on the given parameters. </p>
<p>This function calculates the coefficient by iterating through the elements of the vector P, checking their presence in the bitwise arrays C and AM, and updating the coefficient based on the values in the vector p and the order vector. </p>

<p class="definition">Definition at line <a class="el" href="SRC_8cpp_source.html#l00441">441</a> of file <a class="el" href="SRC_8cpp_source.html">SRC.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  444</span>                                                                                      {</div>
<div class="line"><span class="lineno">  445</span>    <span class="keywordtype">double</span> alpha = 0;</div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordtype">int</span>    S     = 0;</div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt; P.size() - 1; ++j) {</div>
<div class="line"><span class="lineno">  449</span>        <span class="keywordtype">int</span> vj = P[j];</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span>        <span class="comment">// Precompute bitshift values for reuse</span></div>
<div class="line"><span class="lineno">  452</span>        uint64_t am_mask  = (1ULL &lt;&lt; (vj &amp; 63));</div>
<div class="line"><span class="lineno">  453</span>        uint64_t am_index = vj &gt;&gt; 6;</div>
<div class="line"><span class="lineno">  454</span> </div>
<div class="line"><span class="lineno">  455</span>        <span class="comment">// Check if vj is in AM using precomputed values</span></div>
<div class="line"><span class="lineno">  456</span>        <span class="keywordflow">if</span> (!(AM[am_index] &amp; am_mask)) {</div>
<div class="line"><span class="lineno">  457</span>            S = 0; <span class="comment">// Reset S if vj is not in AM</span></div>
<div class="line"><span class="lineno">  458</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (C[am_index] &amp; am_mask) {</div>
<div class="line"><span class="lineno">  459</span>            <span class="comment">// Get the position of vj in C by counting the set bits up to vj</span></div>
<div class="line"><span class="lineno">  460</span>            <span class="keywordtype">int</span> pos = order[vj];</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span>            S += p.<a class="code hl_variable" href="structSRCPermutation.html#ad388d415d55c248d620a00cddc5d686b">num</a>[pos];</div>
<div class="line"><span class="lineno">  463</span> </div>
<div class="line"><span class="lineno">  464</span>            <span class="keywordflow">if</span> (S % p.<a class="code hl_variable" href="structSRCPermutation.html#a73715a9230ef33a4afa75dc51fd09c24">den</a> == 0) {</div>
<div class="line"><span class="lineno">  465</span>                <span class="comment">// S -= 1;</span></div>
<div class="line"><span class="lineno">  466</span>                alpha += 1;</div>
<div class="line"><span class="lineno">  467</span>            }</div>
<div class="line"><span class="lineno">  468</span>        }</div>
<div class="line"><span class="lineno">  469</span>    }</div>
<div class="line"><span class="lineno">  470</span> </div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordflow">return</span> alpha;</div>
<div class="line"><span class="lineno">  472</span>}</div>
<div class="ttc" id="astructSRCPermutation_html_a73715a9230ef33a4afa75dc51fd09c24"><div class="ttname"><a href="structSRCPermutation.html#a73715a9230ef33a4afa75dc51fd09c24">SRCPermutation::den</a></div><div class="ttdeci">int den</div><div class="ttdef"><b>Definition</b> <a href="Cut_8h_source.html#l00017">Cut.h:17</a></div></div>
<div class="ttc" id="astructSRCPermutation_html_ad388d415d55c248d620a00cddc5d686b"><div class="ttname"><a href="structSRCPermutation.html#ad388d415d55c248d620a00cddc5d686b">SRCPermutation::num</a></div><div class="ttdeci">std::vector&lt; int &gt; num</div><div class="ttdef"><b>Definition</b> <a href="Cut_8h_source.html#l00016">Cut.h:16</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a3630f3c02917789164102d02fc4768" name="a6a3630f3c02917789164102d02fc4768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3630f3c02917789164102d02fc4768">&#9670;&#160;</a></span>generateCutCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LimitedMemoryRank1Cuts::generateCutCoefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVRPTW__SRC.html">VRPTW_SRC</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cuts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numNodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates cut coefficients for the given <a class="el" href="structVRPTW__SRC.html" title="A structure to represent the Vehicle Routing Problem with Time Windows (VRPTW) source data.">VRPTW_SRC</a> cuts. </p>
<p>This function generates cut coefficients for the given <a class="el" href="structVRPTW__SRC.html" title="A structure to represent the Vehicle Routing Problem with Time Windows (VRPTW) source data.">VRPTW_SRC</a> cuts using a limited memory rank-1 approach. It processes the cuts in parallel using a thread pool and scheduler, ensuring thread-safe access to shared resources. </p>

<p class="definition">Definition at line <a class="el" href="SRC_8cpp_source.html#l00265">265</a> of file <a class="el" href="SRC_8cpp_source.html">SRC.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  267</span>                                                                                 {</div>
<div class="line"><span class="lineno">  268</span>    <span class="keywordtype">double</span> primal_violation   = 0.0;</div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordtype">int</span>    max_number_of_cuts = 2;</div>
<div class="line"><span class="lineno">  270</span> </div>
<div class="line"><span class="lineno">  271</span>    <span class="keywordflow">if</span> (cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">S_n</a> &gt; 0) {</div>
<div class="line"><span class="lineno">  272</span>        <span class="keywordtype">int</span> m_max = std::min(cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">S_n</a>, max_number_of_cuts);</div>
<div class="line"><span class="lineno">  273</span> </div>
<div class="line"><span class="lineno">  274</span>        <span class="comment">// Prepare thread pool and scheduler</span></div>
<div class="line"><span class="lineno">  275</span>        exec::static_thread_pool pool(std::thread::hardware_concurrency());</div>
<div class="line"><span class="lineno">  276</span>        <span class="keyword">auto</span>                     sched = pool.get_scheduler();</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>        std::mutex cuts_mutex; <span class="comment">// Mutex for cutStorage to ensure thread-safe access</span></div>
<div class="line"><span class="lineno">  279</span> </div>
<div class="line"><span class="lineno">  280</span>        <span class="keyword">auto</span> input_sender = stdexec::just();</div>
<div class="line"><span class="lineno">  281</span> </div>
<div class="line"><span class="lineno">  282</span>        <span class="comment">// Sort best_sets</span></div>
<div class="line"><span class="lineno">  283</span>        pdqsort(cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#af0439c2f86bcda659dbeda1baee6ce67">best_sets</a>.begin(), cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#af0439c2f86bcda659dbeda1baee6ce67">best_sets</a>.end(), std::greater&lt;&gt;());</div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>        <span class="comment">// Define the bulk operation to process each cut</span></div>
<div class="line"><span class="lineno">  286</span>        <span class="keyword">auto</span> bulk_sender = stdexec::bulk(</div>
<div class="line"><span class="lineno">  287</span>            input_sender, m_max, [<span class="keyword">this</span>, &amp;cuts, &amp;coefficients, &amp;x, &amp;numNodes, &amp;cuts_mutex](std::size_t ii) {</div>
<div class="line"><span class="lineno">  288</span>                <span class="keywordflow">if</span> (cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#af0439c2f86bcda659dbeda1baee6ce67">best_sets</a>.empty()) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span>                <span class="keywordtype">int</span> aux_int = cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#af0439c2f86bcda659dbeda1baee6ce67">best_sets</a>[ii].second;</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>                <span class="keywordtype">int</span> start = cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a582b6b3c9b8fd334cea0cb33326d92c9">S</a>[aux_int];</div>
<div class="line"><span class="lineno">  293</span>                <span class="keywordtype">int</span> end   = cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a582b6b3c9b8fd334cea0cb33326d92c9">S</a>[aux_int + 1];</div>
<div class="line"><span class="lineno">  294</span>                <span class="keywordflow">if</span> (end == 0) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  295</span> </div>
<div class="line"><span class="lineno">  296</span>                <span class="comment">// Set up data for each thread</span></div>
<div class="line"><span class="lineno">  297</span>                std::array&lt;uint64_t, num_words&gt; C  = {}; <span class="comment">// Reset C for each cut</span></div>
<div class="line"><span class="lineno">  298</span>                std::array&lt;uint64_t, num_words&gt; AM = {};</div>
<div class="line"><span class="lineno">  299</span>                std::vector&lt;int&gt;                order(N_SIZE, 0);</div>
<div class="line"><span class="lineno">  300</span>                std::vector&lt;double&gt;             coefficients_aux(numNodes, 0.0);</div>
<div class="line"><span class="lineno">  301</span>                std::vector&lt;int&gt;                remainingNodes;</div>
<div class="line"><span class="lineno">  302</span>                remainingNodes.reserve(numNodes);</div>
<div class="line"><span class="lineno">  303</span> </div>
<div class="line"><span class="lineno">  304</span>                <span class="comment">// Build the C set and remaining nodes</span></div>
<div class="line"><span class="lineno">  305</span>                std::vector&lt;int&gt; C_index;</div>
<div class="line"><span class="lineno">  306</span>                C_index.reserve(3);</div>
<div class="line"><span class="lineno">  307</span>                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = start; j &lt; start + 3; ++j) {</div>
<div class="line"><span class="lineno">  308</span>                    <span class="keywordtype">int</span> node = cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>[j];</div>
<div class="line"><span class="lineno">  309</span>                    C[node / 64] |= (1ULL &lt;&lt; (node % 64)); <span class="comment">// Set the bit for node in C</span></div>
<div class="line"><span class="lineno">  310</span>                    C_index.push_back(node);</div>
<div class="line"><span class="lineno">  311</span>                }</div>
<div class="line"><span class="lineno">  312</span>                remainingNodes.assign(cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.begin() + start + 3, cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.begin() + end);</div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span><span class="preprocessor">#ifndef SRC</span></div>
<div class="line"><span class="lineno">  315</span>                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; N_SIZE; ++node) {</div>
<div class="line"><span class="lineno">  316</span>                    AM[node / 64] |= (1ULL &lt;&lt; (node % 64)); <span class="comment">// Set the bit for node in AM</span></div>
<div class="line"><span class="lineno">  317</span>                }</div>
<div class="line"><span class="lineno">  318</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>                ankerl::unordered_dense::set&lt;int&gt; C_set(C_index.begin(), C_index.end());</div>
<div class="line"><span class="lineno">  321</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> node : remainingNodes) {</div>
<div class="line"><span class="lineno">  322</span>                    <span class="keyword">auto</span> &amp;consumers = <a class="code hl_variable" href="#aaad518dd2434c218df7e9283238a6577">allPaths</a>[node]; <span class="comment">// Reference to the consumers for in-place modification</span></div>
<div class="line"><span class="lineno">  323</span> </div>
<div class="line"><span class="lineno">  324</span>                    <span class="keywordtype">int</span> first = -1, second = -1;</div>
<div class="line"><span class="lineno">  325</span> </div>
<div class="line"><span class="lineno">  326</span>                    <span class="comment">// Find the first and second appearances of any element in C_set within consumers</span></div>
<div class="line"><span class="lineno">  327</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; consumers.size() - 1; ++i) {</div>
<div class="line"><span class="lineno">  328</span>                        <span class="keywordflow">if</span> (C_set.find(consumers[i]) != C_set.end()) {</div>
<div class="line"><span class="lineno">  329</span>                            <span class="keywordflow">if</span> (first == -1) {</div>
<div class="line"><span class="lineno">  330</span>                                first = i;</div>
<div class="line"><span class="lineno">  331</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  332</span>                                second = i;</div>
<div class="line"><span class="lineno">  333</span>                                <span class="keywordflow">break</span>; <span class="comment">// We found both first and second, so we can exit the loop</span></div>
<div class="line"><span class="lineno">  334</span>                            }</div>
<div class="line"><span class="lineno">  335</span>                        }</div>
<div class="line"><span class="lineno">  336</span>                    }</div>
<div class="line"><span class="lineno">  337</span> </div>
<div class="line"><span class="lineno">  338</span>                    <span class="comment">// If we found both the first and second indices, mark nodes in AM</span></div>
<div class="line"><span class="lineno">  339</span>                    <span class="keywordflow">if</span> (first != -1 &amp;&amp; second != -1) {</div>
<div class="line"><span class="lineno">  340</span>                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = first + 1; i &lt; second; ++i) {</div>
<div class="line"><span class="lineno">  341</span>                            AM[consumers[i] / 64] |= (1ULL &lt;&lt; (consumers[i] % 64)); <span class="comment">// Set the bit for the consumer</span></div>
<div class="line"><span class="lineno">  342</span>                        }</div>
<div class="line"><span class="lineno">  343</span>                    }</div>
<div class="line"><span class="lineno">  344</span>                }</div>
<div class="line"><span class="lineno">  345</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  346</span>                <span class="comment">// Set order and coefficients_aux</span></div>
<div class="line"><span class="lineno">  347</span>                <span class="keywordtype">int</span> ordering = 0;</div>
<div class="line"><span class="lineno">  348</span>                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = start; j &lt; start + 3; ++j) {</div>
<div class="line"><span class="lineno">  349</span>                    <span class="keywordtype">int</span> node = cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>[j];</div>
<div class="line"><span class="lineno">  350</span>                    AM[node / 64] |= (1ULL &lt;&lt; (node % 64)); <span class="comment">// Set the bit for node in AM</span></div>
<div class="line"><span class="lineno">  351</span>                    order[node] = ordering++;</div>
<div class="line"><span class="lineno">  352</span>                }</div>
<div class="line"><span class="lineno">  353</span> </div>
<div class="line"><span class="lineno">  354</span>                <a class="code hl_struct" href="structSRCPermutation.html">SRCPermutation</a> p;</div>
<div class="line"><span class="lineno">  355</span>                p.<a class="code hl_variable" href="structSRCPermutation.html#ad388d415d55c248d620a00cddc5d686b">num</a> = {1, 1, 1};</div>
<div class="line"><span class="lineno">  356</span>                p.<a class="code hl_variable" href="structSRCPermutation.html#a73715a9230ef33a4afa75dc51fd09c24">den</a> = 2;</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>                <span class="comment">// Iterate over remaining nodes and calculate the coefficients_aux</span></div>
<div class="line"><span class="lineno">  359</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> node : remainingNodes) {</div>
<div class="line"><span class="lineno">  360</span><span class="preprocessor">#ifdef SRC3</span></div>
<div class="line"><span class="lineno">  361</span>                    <span class="keywordflow">for</span> (<span class="keyword">auto</span> c : C_index) { coefficients_aux[node] += <a class="code hl_variable" href="#aaad518dd2434c218df7e9283238a6577">allPaths</a>[node].countOccurrences(c) * 0.5; }</div>
<div class="line"><span class="lineno">  362</span>                    coefficients_aux[node] = std::floor(coefficients_aux[node]);</div>
<div class="line"><span class="lineno">  363</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  364</span><span class="preprocessor">#ifdef SRC</span></div>
<div class="line"><span class="lineno">  365</span>                    <span class="keyword">auto</span> &amp;clients          = <a class="code hl_variable" href="#aaad518dd2434c218df7e9283238a6577">allPaths</a>[node].route; <span class="comment">// Reference to the clients for in-place modification</span></div>
<div class="line"><span class="lineno">  366</span>                    coefficients_aux[node] = <a class="code hl_function" href="#a1b5f8095d331b58224e2e36a985aabb8">computeLimitedMemoryCoefficient</a>(C, AM, p, clients, order);</div>
<div class="line"><span class="lineno">  367</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  368</span>                }</div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>                <span class="comment">// Create and store the cut</span></div>
<div class="line"><span class="lineno">  371</span>                <a class="code hl_struct" href="structCut.html">Cut</a> cut(C, AM, coefficients_aux);</div>
<div class="line"><span class="lineno">  372</span>                cut.baseSetOrder = order;</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>                <span class="comment">// Thread-safe addition of the cut</span></div>
<div class="line"><span class="lineno">  375</span>                {</div>
<div class="line"><span class="lineno">  376</span>                    std::lock_guard&lt;std::mutex&gt; lock(cuts_mutex);</div>
<div class="line"><span class="lineno">  377</span>                    <a class="code hl_variable" href="#a582069540ed19e7a5ec234bd7a0fa4d3">cutStorage</a>.<a class="code hl_function" href="classCutStorage.html#aa59db0e52f4d6d9007f46fdc47324e6c">addCut</a>(cut);</div>
<div class="line"><span class="lineno">  378</span>                }</div>
<div class="line"><span class="lineno">  379</span>            });</div>
<div class="line"><span class="lineno">  380</span> </div>
<div class="line"><span class="lineno">  381</span>        <span class="keyword">auto</span> work = stdexec::starts_on(sched, bulk_sender);</div>
<div class="line"><span class="lineno">  382</span>        stdexec::sync_wait(std::move(work));</div>
<div class="line"><span class="lineno">  383</span>    }</div>
<div class="line"><span class="lineno">  384</span>}</div>
<div class="ttc" id="aclassCutStorage_html_aa59db0e52f4d6d9007f46fdc47324e6c"><div class="ttname"><a href="classCutStorage.html#aa59db0e52f4d6d9007f46fdc47324e6c">CutStorage::addCut</a></div><div class="ttdeci">void addCut(Cut &amp;cut)</div><div class="ttdoc">Adds a cut to the current collection of cuts.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8cpp_source.html#l00072">SRC.cpp:72</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a1b5f8095d331b58224e2e36a985aabb8"><div class="ttname"><a href="#a1b5f8095d331b58224e2e36a985aabb8">LimitedMemoryRank1Cuts::computeLimitedMemoryCoefficient</a></div><div class="ttdeci">double computeLimitedMemoryCoefficient(const std::array&lt; uint64_t, num_words &gt; &amp;C, const std::array&lt; uint64_t, num_words &gt; &amp;AM, const SRCPermutation &amp;p, const std::vector&lt; int &gt; &amp;P, std::vector&lt; int &gt; &amp;order)</div><div class="ttdoc">Computes the limited memory coefficient based on the given parameters.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8cpp_source.html#l00441">SRC.cpp:441</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a582069540ed19e7a5ec234bd7a0fa4d3"><div class="ttname"><a href="#a582069540ed19e7a5ec234bd7a0fa4d3">LimitedMemoryRank1Cuts::cutStorage</a></div><div class="ttdeci">CutStorage cutStorage</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00099">SRC.h:99</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_aaad518dd2434c218df7e9283238a6577"><div class="ttname"><a href="#aaad518dd2434c218df7e9283238a6577">LimitedMemoryRank1Cuts::allPaths</a></div><div class="ttdeci">std::vector&lt; Path &gt; allPaths</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00102">SRC.h:102</a></div></div>
<div class="ttc" id="astructCut_html"><div class="ttname"><a href="structCut.html">Cut</a></div><div class="ttdoc">Represents a cut in the optimization problem.</div><div class="ttdef"><b>Definition</b> <a href="Cut_8h_source.html#l00056">Cut.h:56</a></div></div>
<div class="ttc" id="astructSRCPermutation_html"><div class="ttname"><a href="structSRCPermutation.html">SRCPermutation</a></div><div class="ttdef"><b>Definition</b> <a href="Cut_8h_source.html#l00015">Cut.h:15</a></div></div>
<div class="ttc" id="astructVRPTW__SRC_html_a582b6b3c9b8fd334cea0cb33326d92c9"><div class="ttname"><a href="structVRPTW__SRC.html#a582b6b3c9b8fd334cea0cb33326d92c9">VRPTW_SRC::S</a></div><div class="ttdeci">std::vector&lt; int &gt; S</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00062">SRC.h:62</a></div></div>
<div class="ttc" id="astructVRPTW__SRC_html_a7697890ab8a1ca3afd99620416343b95"><div class="ttname"><a href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">VRPTW_SRC::S_C_P</a></div><div class="ttdeci">std::vector&lt; int &gt; S_C_P</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00063">SRC.h:63</a></div></div>
<div class="ttc" id="astructVRPTW__SRC_html_a89ec8edd59d90d4f43fd1f065c6d176b"><div class="ttname"><a href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">VRPTW_SRC::S_n</a></div><div class="ttdeci">int S_n</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00065">SRC.h:65</a></div></div>
<div class="ttc" id="astructVRPTW__SRC_html_af0439c2f86bcda659dbeda1baee6ce67"><div class="ttname"><a href="structVRPTW__SRC.html#af0439c2f86bcda659dbeda1baee6ce67">VRPTW_SRC::best_sets</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; double, int &gt; &gt; best_sets</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00066">SRC.h:66</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLimitedMemoryRank1Cuts_a6a3630f3c02917789164102d02fc4768_cgraph.png" border="0" usemap="#aclassLimitedMemoryRank1Cuts_a6a3630f3c02917789164102d02fc4768_cgraph" alt=""/></div>
<map name="aclassLimitedMemoryRank1Cuts_a6a3630f3c02917789164102d02fc4768_cgraph" id="aclassLimitedMemoryRank1Cuts_a6a3630f3c02917789164102d02fc4768_cgraph">
<area shape="rect" title="Generates cut coefficients for the given VRPTW_SRC cuts." alt="" coords="5,27,180,68"/>
<area shape="rect" href="classCutStorage.html#aa59db0e52f4d6d9007f46fdc47324e6c" title="Adds a cut to the current collection of cuts." alt="" coords="274,5,408,31"/>
<area shape="poly" title=" " alt="" coords="180,35,258,25,259,31,180,40"/>
<area shape="rect" href="classLimitedMemoryRank1Cuts.html#a1b5f8095d331b58224e2e36a985aabb8" title="Computes the limited memory coefficient based on the given parameters." alt="" coords="228,55,454,96"/>
<area shape="poly" title=" " alt="" coords="180,55,212,58,212,64,180,60"/>
<area shape="rect" href="SRC_8cpp.html#a221ddfa4aa7f40ac52f772b73a3b50ce" title="Computes a unique cut key based on the provided base set and multipliers." alt="" coords="502,5,625,31"/>
<area shape="poly" title=" " alt="" coords="408,16,486,16,486,21,408,21"/>
</map>
</div>

</div>
</div>
<a id="ae9791c60c60f55c1ce5706e6a2b3574c" name="ae9791c60c60f55c1ce5706e6a2b3574c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9791c60c60f55c1ce5706e6a2b3574c">&#9670;&#160;</a></span>insertSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LimitedMemoryRank1Cuts::insertSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVRPTW__SRC.html">VRPTW_SRC</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cuts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer_int</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>buffer_int_n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>LHS_cut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a set of indices and associated data into the <a class="el" href="structVRPTW__SRC.html" title="A structure to represent the Vehicle Routing Problem with Time Windows (VRPTW) source data.">VRPTW_SRC</a> cuts structure. </p>
<p>This function inserts a set of indices (i, j, k) and additional buffer data into the <a class="el" href="structVRPTW__SRC.html" title="A structure to represent the Vehicle Routing Problem with Time Windows (VRPTW) source data.">VRPTW_SRC</a> cuts structure. It ensures that the underlying storage has enough capacity to accommodate the new data and resizes it if necessary. The function also updates the best sets and the S_C_P vector with the new data. </p>

<p class="definition">Definition at line <a class="el" href="SRC_8cpp_source.html#l00224">224</a> of file <a class="el" href="SRC_8cpp_source.html">SRC.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  225</span>                                                                         {</div>
<div class="line"><span class="lineno">  226</span>    <span class="comment">// Estimate size to avoid frequent reallocations</span></div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordtype">size_t</span> required_size = cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.size() + 3 + buffer_int_n;</div>
<div class="line"><span class="lineno">  228</span>    <span class="keywordflow">if</span> (required_size &gt; cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.capacity()) {</div>
<div class="line"><span class="lineno">  229</span>        <span class="keywordtype">size_t</span> new_size =</div>
<div class="line"><span class="lineno">  230</span>            <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(std::ceil(required_size * 2.0)); <span class="comment">// Double the size to avoid frequent reallocations</span></div>
<div class="line"><span class="lineno">  231</span>        cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.reserve(new_size);</div>
<div class="line"><span class="lineno">  232</span>        cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#aff3fda917437656b383c579fb48f20fc">S_C_P_max</a> = new_size;</div>
<div class="line"><span class="lineno">  233</span>    }</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span>    <span class="comment">// Insert best set with emplace_back to avoid extra copies</span></div>
<div class="line"><span class="lineno">  236</span>    cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#af0439c2f86bcda659dbeda1baee6ce67">best_sets</a>.emplace_back(LHS_cut, cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">S_n</a>);</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>    <span class="comment">// Resize cuts.S only if needed and in larger chunks</span></div>
<div class="line"><span class="lineno">  239</span>    <span class="keywordflow">if</span> (cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a582b6b3c9b8fd334cea0cb33326d92c9">S</a>.size() &lt;= cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">S_n</a>) {</div>
<div class="line"><span class="lineno">  240</span>        cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a582b6b3c9b8fd334cea0cb33326d92c9">S</a>.resize(cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">S_n</a> + 10); <span class="comment">// Resize in larger chunks to reduce frequent resizing</span></div>
<div class="line"><span class="lineno">  241</span>    }</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>    <span class="comment">// Store the current index of cuts.S_C_P for this set</span></div>
<div class="line"><span class="lineno">  244</span>    cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a582b6b3c9b8fd334cea0cb33326d92c9">S</a>[cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">S_n</a>] = cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.size();</div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span>    <span class="comment">// Directly insert the values into S_C_P</span></div>
<div class="line"><span class="lineno">  247</span>    cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.push_back(i);</div>
<div class="line"><span class="lineno">  248</span>    cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.push_back(j);</div>
<div class="line"><span class="lineno">  249</span>    cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.push_back(k);</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>    <span class="comment">// Use bulk insert for buffer_int to reduce loop overhead</span></div>
<div class="line"><span class="lineno">  252</span>    cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.insert(cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a7697890ab8a1ca3afd99620416343b95">S_C_P</a>.end(), buffer_int.begin(), buffer_int.begin() + buffer_int_n);</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>    <span class="comment">// Increment the set counter</span></div>
<div class="line"><span class="lineno">  255</span>    cuts.<a class="code hl_variable" href="structVRPTW__SRC.html#a89ec8edd59d90d4f43fd1f065c6d176b">S_n</a>++;</div>
<div class="line"><span class="lineno">  256</span>}</div>
<div class="ttc" id="astructVRPTW__SRC_html_aff3fda917437656b383c579fb48f20fc"><div class="ttname"><a href="structVRPTW__SRC.html#aff3fda917437656b383c579fb48f20fc">VRPTW_SRC::S_C_P_max</a></div><div class="ttdeci">int S_C_P_max</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00064">SRC.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b5298782f45bc4106a5397a4c0b9705" name="a2b5298782f45bc4106a5397a4c0b9705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5298782f45bc4106a5397a4c0b9705">&#9670;&#160;</a></span>prepare45Heuristic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LimitedMemoryRank1Cuts::prepare45Heuristic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00140">140</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  140</span>                                                                                           {</div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordtype">int</span> max_important_nodes = 10;</div>
<div class="line"><span class="lineno">  142</span>        <a class="code hl_variable" href="#afd9fbfe139aabbb019ed099c0b485f5c">the45selectedNodes</a>      = <a class="code hl_function" href="#a29f6f1ce5f46f80b1e8840ccd5b0521a">selectHighestCoefficients</a>(x, max_important_nodes);</div>
<div class="line"><span class="lineno">  143</span>    }</div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a29f6f1ce5f46f80b1e8840ccd5b0521a"><div class="ttname"><a href="#a29f6f1ce5f46f80b1e8840ccd5b0521a">LimitedMemoryRank1Cuts::selectHighestCoefficients</a></div><div class="ttdeci">std::vector&lt; int &gt; selectHighestCoefficients(const std::vector&lt; double &gt; &amp;x, int maxNodes)</div><div class="ttdoc">Selects the indices of the highest coefficients from a given vector.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8cpp_source.html#l00473">SRC.cpp:473</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_afd9fbfe139aabbb019ed099c0b485f5c"><div class="ttname"><a href="#afd9fbfe139aabbb019ed099c0b485f5c">LimitedMemoryRank1Cuts::the45selectedNodes</a></div><div class="ttdeci">std::vector&lt; int &gt; the45selectedNodes</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00139">SRC.h:139</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLimitedMemoryRank1Cuts_a2b5298782f45bc4106a5397a4c0b9705_cgraph.png" border="0" usemap="#aclassLimitedMemoryRank1Cuts_a2b5298782f45bc4106a5397a4c0b9705_cgraph" alt=""/></div>
<map name="aclassLimitedMemoryRank1Cuts_a2b5298782f45bc4106a5397a4c0b9705_cgraph" id="aclassLimitedMemoryRank1Cuts_a2b5298782f45bc4106a5397a4c0b9705_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,180,46"/>
<area shape="rect" href="classLimitedMemoryRank1Cuts.html#a29f6f1ce5f46f80b1e8840ccd5b0521a" title="Selects the indices of the highest coefficients from a given vector." alt="" coords="228,5,402,46"/>
<area shape="poly" title=" " alt="" coords="180,23,212,23,212,28,180,28"/>
</map>
</div>

</div>
</div>
<a id="a97184beb1ff942ca01ffa2ab2bf18f1a" name="a97184beb1ff942ca01ffa2ab2bf18f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97184beb1ff942ca01ffa2ab2bf18f1a">&#9670;&#160;</a></span>printBaseSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LimitedMemoryRank1Cuts::printBaseSets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4dde5f58774e939e3ce6635cbf9dc91e" name="a4dde5f58774e939e3ce6635cbf9dc91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dde5f58774e939e3ce6635cbf9dc91e">&#9670;&#160;</a></span>runSeparation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, bool &gt; LimitedMemoryRank1Cuts::runSeparation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBNBNode.html">BNBNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbaldes_1_1Constraint.html">baldes::Constraint</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>SRCconstraints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8cpp_source.html#l00386">386</a> of file <a class="el" href="SRC_8cpp_source.html">SRC.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  386</span>                                                                                                                      {</div>
<div class="line"><span class="lineno">  387</span>    node-&gt;<a class="code hl_function" href="classBNBNode.html#abb76f5afa8990290b262a0750cede865">optimize</a>();</div>
<div class="line"><span class="lineno">  388</span>    <span class="keyword">auto</span>      solution = node-&gt;<a class="code hl_function" href="classBNBNode.html#ac5cdf235b03dab790bc9ec7222592375">extractSolution</a>();</div>
<div class="line"><span class="lineno">  389</span>    <span class="keyword">auto</span>      cuts     = &amp;<a class="code hl_variable" href="#a582069540ed19e7a5ec234bd7a0fa4d3">cutStorage</a>;</div>
<div class="line"><span class="lineno">  390</span>    <a class="code hl_struct" href="structModelData.html">ModelData</a> matrix;</div>
<div class="line"><span class="lineno">  391</span> </div>
<div class="line"><span class="lineno">  392</span>    <span class="keyword">auto</span> cuts_before = cuts-&gt;size();</div>
<div class="line"><span class="lineno">  394</span>    <span class="comment">// Handle non-violated cuts in a single pass</span></div>
<div class="line"><span class="lineno">  396</span>    <span class="keywordtype">bool</span> cleared        = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  397</span>    <span class="keyword">auto</span> n_cuts_removed = 0;</div>
<div class="line"><span class="lineno">  398</span>    <span class="comment">// Iterate over the constraints in reverse order to remove non-violated cuts</span></div>
<div class="line"><span class="lineno">  399</span>    <span class="comment">// sort SRCconstraints by index</span></div>
<div class="line"><span class="lineno">  400</span>    std::sort(SRCconstraints.begin(), SRCconstraints.end(),</div>
<div class="line"><span class="lineno">  401</span>              [](<span class="keyword">const</span> <a class="code hl_class" href="classbaldes_1_1Constraint.html">baldes::Constraint</a> *a, <span class="keyword">const</span> <a class="code hl_class" href="classbaldes_1_1Constraint.html">baldes::Constraint</a> *b) { return a-&gt;index() &lt; b-&gt;index(); });</div>
<div class="line"><span class="lineno">  402</span> </div>
<div class="line"><span class="lineno">  403</span>    <span class="comment">//if (cleared) node-&gt;optimize();</span></div>
<div class="line"><span class="lineno">  404</span>    matrix   = node-&gt;<a class="code hl_function" href="classBNBNode.html#a234c0a33d282f8ec5d1017de8c99a037">extractModelDataSparse</a>(); <span class="comment">// Extract model data</span></div>
<div class="line"><span class="lineno">  405</span>    solution = node-&gt;<a class="code hl_function" href="classBNBNode.html#ac5cdf235b03dab790bc9ec7222592375">extractSolution</a>();</div>
<div class="line"><span class="lineno">  406</span>    <a class="code hl_function" href="#a34eb8134a3b061fc6e19ae25f6fa3599">separate</a>(matrix.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>, solution);</div>
<div class="line"><span class="lineno">  407</span>    <a class="code hl_function" href="#a2b5298782f45bc4106a5397a4c0b9705">prepare45Heuristic</a>(matrix.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>, solution);</div>
<div class="line"><span class="lineno">  408</span>    <a class="code hl_function" href="#a7b3eba87af98185081086c5f5b34c5ce">the45Heuristic&lt;CutType::FourRow&gt;</a>(matrix.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>, solution);</div>
<div class="line"><span class="lineno">  409</span>    <a class="code hl_function" href="#a7b3eba87af98185081086c5f5b34c5ce">the45Heuristic&lt;CutType::FiveRow&gt;</a>(matrix.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>, solution);</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = SRCconstraints.size() - 1; i &gt;= 0; --i) {</div>
<div class="line"><span class="lineno">  412</span>        <span class="keyword">auto</span> constr = SRCconstraints[i];</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>        <span class="comment">// Get the slack value of the constraint</span></div>
<div class="line"><span class="lineno">  415</span>        <span class="keywordtype">double</span> slack = node-&gt;<a class="code hl_function" href="classBNBNode.html#ac4a92f0a90b0517dda3eb0e08c1ffe72">getSlack</a>(constr-&gt;index(), solution);</div>
<div class="line"><span class="lineno">  416</span>        <span class="comment">// double slack = slacks[constr-&gt;index()];</span></div>
<div class="line"><span class="lineno">  417</span> </div>
<div class="line"><span class="lineno">  418</span>        <span class="comment">// If the slack is positive, it means the constraint is not violated</span></div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">if</span> (slack &gt; 1e-3) {</div>
<div class="line"><span class="lineno">  420</span>            cleared = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span>            <span class="comment">// Remove the constraint from the model and cut storage</span></div>
<div class="line"><span class="lineno">  423</span>            node-&gt;<a class="code hl_function" href="classBNBNode.html#ab52a2729370e2cfde6eb7fec9b46d70d">remove</a>(constr);</div>
<div class="line"><span class="lineno">  424</span>            cuts-&gt;removeCut(cuts-&gt;getID(i));</div>
<div class="line"><span class="lineno">  425</span>            n_cuts_removed++;</div>
<div class="line"><span class="lineno">  426</span> </div>
<div class="line"><span class="lineno">  427</span>            <span class="comment">// Remove from SRCconstraints</span></div>
<div class="line"><span class="lineno">  428</span>            SRCconstraints.erase(SRCconstraints.begin() + i);</div>
<div class="line"><span class="lineno">  429</span>        }</div>
<div class="line"><span class="lineno">  430</span>    }</div>
<div class="line"><span class="lineno">  431</span>    </div>
<div class="line"><span class="lineno">  432</span>    <span class="keywordflow">if</span> (cuts_before == cuts-&gt;size() + n_cuts_removed) { <span class="keywordflow">return</span> std::make_pair(<span class="keyword">false</span>, cleared); }</div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, cleared);</div>
<div class="line"><span class="lineno">  435</span>}</div>
<div class="ttc" id="aclassBNBNode_html_a234c0a33d282f8ec5d1017de8c99a037"><div class="ttname"><a href="classBNBNode.html#a234c0a33d282f8ec5d1017de8c99a037">BNBNode::extractModelDataSparse</a></div><div class="ttdeci">ModelData extractModelDataSparse()</div><div class="ttdef"><b>Definition</b> <a href="Node_8h_source.html#l00313">Node.h:313</a></div></div>
<div class="ttc" id="aclassBNBNode_html_ab52a2729370e2cfde6eb7fec9b46d70d"><div class="ttname"><a href="classBNBNode.html#ab52a2729370e2cfde6eb7fec9b46d70d">BNBNode::remove</a></div><div class="ttdeci">void remove(baldes::Constraint *ctr)</div><div class="ttdef"><b>Definition</b> <a href="Node_8h_source.html#l00271">Node.h:271</a></div></div>
<div class="ttc" id="aclassBNBNode_html_abb76f5afa8990290b262a0750cede865"><div class="ttname"><a href="classBNBNode.html#abb76f5afa8990290b262a0750cede865">BNBNode::optimize</a></div><div class="ttdeci">void optimize(double tol=1e-6)</div><div class="ttdef"><b>Definition</b> <a href="Node_8h_source.html#l00323">Node.h:323</a></div></div>
<div class="ttc" id="aclassBNBNode_html_ac4a92f0a90b0517dda3eb0e08c1ffe72"><div class="ttname"><a href="classBNBNode.html#ac4a92f0a90b0517dda3eb0e08c1ffe72">BNBNode::getSlack</a></div><div class="ttdeci">double getSlack(int constraintIndex, const std::vector&lt; double &gt; &amp;solution)</div><div class="ttdef"><b>Definition</b> <a href="Node_8h_source.html#l00248">Node.h:248</a></div></div>
<div class="ttc" id="aclassBNBNode_html_ac5cdf235b03dab790bc9ec7222592375"><div class="ttname"><a href="classBNBNode.html#ac5cdf235b03dab790bc9ec7222592375">BNBNode::extractSolution</a></div><div class="ttdeci">std::vector&lt; double &gt; extractSolution()</div><div class="ttdef"><b>Definition</b> <a href="Node_8h_source.html#l00322">Node.h:322</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a2b5298782f45bc4106a5397a4c0b9705"><div class="ttname"><a href="#a2b5298782f45bc4106a5397a4c0b9705">LimitedMemoryRank1Cuts::prepare45Heuristic</a></div><div class="ttdeci">void prepare45Heuristic(const SparseMatrix &amp;A, const std::vector&lt; double &gt; &amp;x)</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00140">SRC.h:140</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a34eb8134a3b061fc6e19ae25f6fa3599"><div class="ttname"><a href="#a34eb8134a3b061fc6e19ae25f6fa3599">LimitedMemoryRank1Cuts::separate</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; double &gt; &gt; separate(const SparseMatrix &amp;A, const std::vector&lt; double &gt; &amp;x)</div><div class="ttdoc">Separates the given solution vector into cuts using Limited Memory Rank-1 Cuts.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8cpp_source.html#l00116">SRC.cpp:116</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a7b3eba87af98185081086c5f5b34c5ce"><div class="ttname"><a href="#a7b3eba87af98185081086c5f5b34c5ce">LimitedMemoryRank1Cuts::the45Heuristic</a></div><div class="ttdeci">void the45Heuristic(const SparseMatrix &amp;A, const std::vector&lt; double &gt; &amp;x)</div><div class="ttdoc">Implements the 45 Heuristic for generating limited memory rank-1 cuts.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00321">SRC.h:321</a></div></div>
<div class="ttc" id="aclassbaldes_1_1Constraint_html"><div class="ttname"><a href="classbaldes_1_1Constraint.html">baldes::Constraint</a></div><div class="ttdoc">Represents a linear constraint in a mathematical optimization problem.</div><div class="ttdef"><b>Definition</b> <a href="Constraint_8h_source.html#l00021">Constraint.h:21</a></div></div>
<div class="ttc" id="astructModelData_html"><div class="ttname"><a href="structModelData.html">ModelData</a></div><div class="ttdoc">Represents the data structure for a mathematical model.</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00148">Definitions.h:148</a></div></div>
<div class="ttc" id="astructModelData_html_a245b4a1967df894ba7ef7ed10a2c111a"><div class="ttname"><a href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">ModelData::A_sparse</a></div><div class="ttdeci">SparseMatrix A_sparse</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00149">Definitions.h:149</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLimitedMemoryRank1Cuts_a4dde5f58774e939e3ce6635cbf9dc91e_cgraph.png" border="0" usemap="#aclassLimitedMemoryRank1Cuts_a4dde5f58774e939e3ce6635cbf9dc91e_cgraph" alt=""/></div>
<map name="aclassLimitedMemoryRank1Cuts_a4dde5f58774e939e3ce6635cbf9dc91e_cgraph" id="aclassLimitedMemoryRank1Cuts_a4dde5f58774e939e3ce6635cbf9dc91e_cgraph">
<area shape="rect" title=" " alt="" coords="5,412,180,453"/>
<area shape="rect" href="classBNBNode.html#a234c0a33d282f8ec5d1017de8c99a037" title=" " alt="" coords="228,115,415,156"/>
<area shape="poly" title=" " alt="" coords="98,411,115,366,142,307,179,243,226,184,255,162,258,166,230,188,183,246,147,309,120,368,103,413"/>
<area shape="rect" href="classBNBNode.html#ac5cdf235b03dab790bc9ec7222592375" title=" " alt="" coords="235,199,408,224"/>
<area shape="poly" title=" " alt="" coords="104,410,153,340,187,299,226,261,274,230,277,234,229,266,191,303,157,343,109,413"/>
<area shape="rect" href="classBNBNode.html#ac4a92f0a90b0517dda3eb0e08c1ffe72" title=" " alt="" coords="253,276,390,302"/>
<area shape="poly" title=" " alt="" coords="125,410,285,308,288,312,128,414"/>
<area shape="rect" href="classBNBNode.html#abb76f5afa8990290b262a0750cede865" title=" " alt="" coords="254,391,388,416"/>
<area shape="poly" title=" " alt="" coords="180,419,238,411,239,417,180,424"/>
<area shape="rect" href="classLimitedMemoryRank1Cuts.html#a2b5298782f45bc4106a5397a4c0b9705" title=" " alt="" coords="234,440,408,481"/>
<area shape="poly" title=" " alt="" coords="180,441,219,446,218,451,180,446"/>
<area shape="rect" href="classBNBNode.html#ab52a2729370e2cfde6eb7fec9b46d70d" title=" " alt="" coords="257,505,386,531"/>
<area shape="poly" title=" " alt="" coords="137,451,229,490,252,498,250,503,227,495,135,456"/>
<area shape="rect" href="classLimitedMemoryRank1Cuts.html#a34eb8134a3b061fc6e19ae25f6fa3599" title="Separates the given solution vector into cuts using Limited Memory Rank&#45;1 Cuts." alt="" coords="234,555,408,596"/>
<area shape="poly" title=" " alt="" coords="116,451,165,496,229,541,238,546,236,551,226,546,162,500,112,455"/>
<area shape="rect" href="classLimitedMemoryRank1Cuts.html#a7b3eba87af98185081086c5f5b34c5ce" title="Implements the 45 Heuristic for generating limited memory rank&#45;1 cuts." alt="" coords="234,640,408,681"/>
<area shape="poly" title=" " alt="" coords="108,452,157,525,191,567,229,605,264,630,261,635,226,610,187,570,153,528,104,455"/>
<area shape="rect" href="classMIPProblem.html#ae1444b927d088a4f9d35dfe604aeb7d9" title=" " alt="" coords="464,96,637,137"/>
<area shape="poly" title=" " alt="" coords="415,125,448,123,448,128,416,131"/>
<area shape="rect" href="classMIPProblem.html#ab90d73fab03bc3983fe3b263c447eb9b" title=" " alt="" coords="703,5,834,31"/>
<area shape="poly" title=" " alt="" coords="583,94,630,66,684,40,700,34,702,39,686,45,632,71,585,98"/>
<area shape="rect" href="classMIPProblem.html#a5f3fa530fb8a6061e1d294a1857dd250" title=" " alt="" coords="701,55,836,80"/>
<area shape="poly" title=" " alt="" coords="637,95,693,82,694,87,638,100"/>
<area shape="rect" href="classMIPProblem.html#a00841d8835fad12f1b35e83d7b5cf9a5" title=" " alt="" coords="685,104,852,130"/>
<area shape="poly" title=" " alt="" coords="637,114,670,114,670,120,637,120"/>
<area shape="rect" href="classMIPProblem.html#a94d7739fb700ed6194d73ddea3a870e8" title=" " alt="" coords="699,153,838,179"/>
<area shape="poly" title=" " alt="" coords="638,134,694,147,693,152,637,139"/>
<area shape="rect" href="classMIPProblem.html#a29674f674d7f14b118a031cdf734611e" title=" " alt="" coords="687,203,850,228"/>
<area shape="poly" title=" " alt="" coords="614,135,639,148,663,169,673,179,687,189,697,194,694,199,684,194,669,183,659,173,636,152,612,140"/>
<area shape="rect" href="classSolverInterface.html#a2bd025d0a840837c01533e10fbfb7571" title=" " alt="" coords="473,162,627,202"/>
<area shape="poly" title=" " alt="" coords="407,198,457,191,458,197,408,203"/>
<area shape="rect" href="classMIPProblem.html#a819af412ba3883842beb711ce69e92fa" title=" " alt="" coords="475,227,625,252"/>
<area shape="poly" title=" " alt="" coords="384,273,472,254,473,259,385,278"/>
<area shape="rect" href="classSolverInterface.html#ac588d11a5e7e692e748a064e612e4059" title=" " alt="" coords="467,276,633,302"/>
<area shape="poly" title=" " alt="" coords="391,286,452,286,452,292,391,292"/>
<area shape="rect" href="classGurobiEnvSingleton.html#a49c3ce63088629c2246dec252a73df16" title=" " alt="" coords="482,326,618,366"/>
<area shape="poly" title=" " alt="" coords="375,387,467,364,468,369,376,393"/>
<area shape="rect" href="classSolverInterface.html#aeaac9dd85da0f259e9804a9970a7f54f" title=" " alt="" coords="468,391,632,416"/>
<area shape="poly" title=" " alt="" coords="389,401,453,401,453,406,389,406"/>
<area shape="rect" href="classSolverInterface.html#afc4cb03aa6a487dd87a2a2d3090a5577" title=" " alt="" coords="466,440,634,466"/>
<area shape="poly" title=" " alt="" coords="385,414,473,434,472,439,384,420"/>
<area shape="rect" href="classLimitedMemoryRank1Cuts.html#a29f6f1ce5f46f80b1e8840ccd5b0521a" title="Selects the indices of the highest coefficients from a given vector." alt="" coords="463,490,637,530"/>
<area shape="poly" title=" " alt="" coords="409,477,449,486,447,491,408,482"/>
<area shape="rect" href="classMIPProblem.html#a4e55c60ce1b0dfd21733f9fbbc157891" title=" " alt="" coords="483,555,617,596"/>
<area shape="poly" title=" " alt="" coords="376,529,468,552,467,558,375,534"/>
<area shape="rect" href="structSparseMatrix.html#ac25e8f241cd1de61244dcff74c474799" title=" " alt="" coords="685,563,852,588"/>
<area shape="poly" title=" " alt="" coords="618,573,670,573,670,578,618,578"/>
<area shape="rect" href="SRC_8h.html#ac1e86f60f149c469a628f58f3e595221" title="Generates all combinations of a given size from a set of elements." alt="" coords="501,620,599,646"/>
<area shape="poly" title=" " alt="" coords="408,648,485,638,486,643,409,653"/>
<area shape="rect" href="SRC_8h.html#abd5d9a806975ce95efb3b8ce3e6fe2e5" title="Generates all unique permutations of a fixed&#45;size vector." alt="" coords="466,669,634,695"/>
<area shape="poly" title=" " alt="" coords="409,666,451,670,451,676,409,672"/>
<area shape="rect" href="SRC_8h.html#a0ec7e413b362fcfa33e475b88198ff9b" title="Generates all unique permutations for a predefined set of vectors of size 5." alt="" coords="466,719,634,744"/>
<area shape="poly" title=" " alt="" coords="384,679,464,705,485,711,484,716,462,710,383,684"/>
</map>
</div>

</div>
</div>
<a id="a29f6f1ce5f46f80b1e8840ccd5b0521a" name="a29f6f1ce5f46f80b1e8840ccd5b0521a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f6f1ce5f46f80b1e8840ccd5b0521a">&#9670;&#160;</a></span>selectHighestCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; LimitedMemoryRank1Cuts::selectHighestCoefficients </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxNodes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the indices of the highest coefficients from a given vector. </p>
<p>This function takes a vector of doubles and an integer specifying the maximum number of nodes to select. It filters out elements with coefficients less than or equal to 1e-2, sorts the remaining elements in descending order based on their coefficients, and returns the indices of the top elements up to the specified maximum number of nodes. </p>

<p class="definition">Definition at line <a class="el" href="SRC_8cpp_source.html#l00473">473</a> of file <a class="el" href="SRC_8cpp_source.html">SRC.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  473</span>                                                                                                         {</div>
<div class="line"><span class="lineno">  474</span>    <span class="comment">// Min-heap to store the top maxNodes elements</span></div>
<div class="line"><span class="lineno">  475</span>    std::priority_queue&lt;std::pair&lt;double, int&gt;, std::vector&lt;std::pair&lt;double, int&gt;&gt;, std::greater&lt;&gt;&gt; minHeap;</div>
<div class="line"><span class="lineno">  476</span> </div>
<div class="line"><span class="lineno">  477</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_variable" href="#aaad518dd2434c218df7e9283238a6577">allPaths</a>.size(); ++i) {</div>
<div class="line"><span class="lineno">  478</span>        <span class="keywordflow">if</span> (x[i] &gt; 1e-2) {</div>
<div class="line"><span class="lineno">  479</span>            <span class="keywordflow">if</span> (minHeap.size() &lt; maxNodes) {</div>
<div class="line"><span class="lineno">  480</span>                minHeap.push({x[i], i});</div>
<div class="line"><span class="lineno">  481</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x[i] &gt; minHeap.top().first) {</div>
<div class="line"><span class="lineno">  482</span>                minHeap.pop();</div>
<div class="line"><span class="lineno">  483</span>                minHeap.push({x[i], i});</div>
<div class="line"><span class="lineno">  484</span>            }</div>
<div class="line"><span class="lineno">  485</span>        }</div>
<div class="line"><span class="lineno">  486</span>    }</div>
<div class="line"><span class="lineno">  487</span> </div>
<div class="line"><span class="lineno">  488</span>    <span class="comment">// Extract elements from the heap into the result vector</span></div>
<div class="line"><span class="lineno">  489</span>    std::vector&lt;int&gt; selectedNodes;</div>
<div class="line"><span class="lineno">  490</span>    selectedNodes.reserve(minHeap.size());</div>
<div class="line"><span class="lineno">  491</span>    <span class="keywordflow">while</span> (!minHeap.empty()) {</div>
<div class="line"><span class="lineno">  492</span>        selectedNodes.push_back(minHeap.top().second);</div>
<div class="line"><span class="lineno">  493</span>        minHeap.pop();</div>
<div class="line"><span class="lineno">  494</span>    }</div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span>    <span class="comment">// Since it&#39;s a min-heap, you might want to reverse the order for descending coefficients</span></div>
<div class="line"><span class="lineno">  497</span>    std::reverse(selectedNodes.begin(), selectedNodes.end());</div>
<div class="line"><span class="lineno">  498</span> </div>
<div class="line"><span class="lineno">  499</span>    <span class="keywordflow">return</span> selectedNodes;</div>
<div class="line"><span class="lineno">  500</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34eb8134a3b061fc6e19ae25f6fa3599" name="a34eb8134a3b061fc6e19ae25f6fa3599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34eb8134a3b061fc6e19ae25f6fa3599">&#9670;&#160;</a></span>separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; LimitedMemoryRank1Cuts::separate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates the given solution vector into cuts using Limited Memory Rank-1 Cuts. </p>
<p>This function generates cuts for the given solution vector <code>x</code> based on the sparse model <code>A</code>. It uses a parallel approach to evaluate combinations of indices and identify violations that exceed the specified threshold. </p>

<p class="definition">Definition at line <a class="el" href="SRC_8cpp_source.html#l00116">116</a> of file <a class="el" href="SRC_8cpp_source.html">SRC.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  116</span>                                                                                                               {</div>
<div class="line"><span class="lineno">  117</span>    <span class="comment">// Create a map for non-zero entries by rows</span></div>
<div class="line"><span class="lineno">  118</span>    std::vector&lt;std::vector&lt;int&gt;&gt; row_indices_map(N_SIZE);</div>
<div class="line"><span class="lineno">  119</span>    <span class="comment">// print num_rows</span></div>
<div class="line"><span class="lineno">  120</span>    <span class="comment">// fmt::print(&quot;Num rows: {}\n&quot;, A.num_rows);</span></div>
<div class="line"><span class="lineno">  121</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; A.<a class="code hl_variable" href="structSparseMatrix.html#accda920bb43c45ca83da3cc8c7ad4561">values</a>.size(); ++idx) {</div>
<div class="line"><span class="lineno">  122</span>        <span class="keywordtype">int</span> row = A.<a class="code hl_variable" href="structSparseMatrix.html#a0e1b1a48ae0246c841fcc0cd301ca940">rows</a>[idx];</div>
<div class="line"><span class="lineno">  123</span>        <span class="comment">// fmt::print(&quot;Row: {}\n&quot;, row);</span></div>
<div class="line"><span class="lineno">  124</span>        <span class="keywordflow">if</span> (row &gt; N_SIZE - 2) { <span class="keywordflow">continue</span>; }</div>
<div class="line"><span class="lineno">  125</span>        row_indices_map[row + 1].push_back(idx);</div>
<div class="line"><span class="lineno">  126</span>    }</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>    <span class="keyword">auto</span> cuts    = <a class="code hl_struct" href="structVRPTW__SRC.html">VRPTW_SRC</a>();</div>
<div class="line"><span class="lineno">  129</span>    cuts.S_n_max = <a class="code hl_define" href="SRC_8h.html#a9ed98a20ad5b3389f821d145e4fee5ea">VRPTW_SRC_max_S_n</a>;</div>
<div class="line"><span class="lineno">  130</span>    cuts.S.resize(cuts.S_n_max + 1);</div>
<div class="line"><span class="lineno">  131</span>    cuts.S_n       = 0;</div>
<div class="line"><span class="lineno">  132</span>    cuts.S_C_P_max = 50 * cuts.S_n_max;</div>
<div class="line"><span class="lineno">  133</span>    cuts.S_C_P.resize(cuts.S_C_P_max);</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>    <span class="keyword">const</span> <span class="keywordtype">int</span>                JOBS = std::thread::hardware_concurrency();</div>
<div class="line"><span class="lineno">  136</span>    exec::static_thread_pool pool(JOBS);</div>
<div class="line"><span class="lineno">  137</span>    <span class="keyword">auto</span>                     sched = pool.get_scheduler();</div>
<div class="line"><span class="lineno">  138</span> </div>
<div class="line"><span class="lineno">  139</span>    <span class="keyword">auto</span>                                   nC = N_SIZE;</div>
<div class="line"><span class="lineno">  140</span>    std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; tasks;</div>
<div class="line"><span class="lineno">  141</span>    tasks.reserve((nC * (nC - 1) * (nC - 2)) / 6); <span class="comment">// Preallocate task space to avoid reallocations</span></div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    <span class="comment">// Create tasks for each combination of (i, j, k)</span></div>
<div class="line"><span class="lineno">  144</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; N_SIZE - 1; ++i) {</div>
<div class="line"><span class="lineno">  145</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i + 1; j &lt; N_SIZE - 1; ++j) {</div>
<div class="line"><span class="lineno">  146</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = j + 1; k &lt; N_SIZE - 1; ++k) { tasks.emplace_back(i, j, k); }</div>
<div class="line"><span class="lineno">  147</span>        }</div>
<div class="line"><span class="lineno">  148</span>    }</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span>    <span class="comment">// Define chunk size to reduce parallelization overhead</span></div>
<div class="line"><span class="lineno">  151</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> chunk_size = 10; <span class="comment">// Adjust chunk size based on performance experiments</span></div>
<div class="line"><span class="lineno">  152</span><span class="preprocessor">#ifdef NSYNC</span></div>
<div class="line"><span class="lineno">  153</span>    nsync::nsync_mu cuts_mutex = NSYNC_MU_INIT;</div>
<div class="line"><span class="lineno">  154</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  155</span>    std::mutex cuts_mutex; <span class="comment">// Protect access to shared resources</span></div>
<div class="line"><span class="lineno">  156</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  157</span> </div>
<div class="line"><span class="lineno">  158</span>    <span class="comment">// Parallel execution in chunks</span></div>
<div class="line"><span class="lineno">  159</span>    <span class="keyword">auto</span> bulk_sender = stdexec::bulk(</div>
<div class="line"><span class="lineno">  160</span>        stdexec::just(), (tasks.size() + chunk_size - 1) / chunk_size,</div>
<div class="line"><span class="lineno">  161</span>        [<span class="keyword">this</span>, &amp;row_indices_map, &amp;A, &amp;x, nC, &amp;cuts, &amp;cuts_mutex, &amp;tasks, chunk_size](std::size_t chunk_idx) {</div>
<div class="line"><span class="lineno">  162</span>            size_t start_idx = chunk_idx * chunk_size;</div>
<div class="line"><span class="lineno">  163</span>            size_t end_idx   = std::min(start_idx + chunk_size, tasks.size());</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>            <span class="comment">// Process a chunk of tasks</span></div>
<div class="line"><span class="lineno">  166</span>            for (size_t task_idx = start_idx; task_idx &lt; end_idx; ++task_idx) {</div>
<div class="line"><span class="lineno">  167</span>                const auto &amp;[i, j, k] = tasks[task_idx];</div>
<div class="line"><span class="lineno">  168</span>                std::vector&lt;int&gt; expanded(A.num_cols, 0);</div>
<div class="line"><span class="lineno">  169</span>                std::vector&lt;int&gt; buffer_int(A.num_cols);</div>
<div class="line"><span class="lineno">  170</span>                int              buffer_int_n = 0;</div>
<div class="line"><span class="lineno">  171</span>                double           lhs          = 0.0;</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>                <span class="comment">// Combine the three updates into one loop for efficiency</span></div>
<div class="line"><span class="lineno">  174</span>                for (int idx : row_indices_map[i]) expanded[A.cols[idx]] += 1;</div>
<div class="line"><span class="lineno">  175</span>                for (int idx : row_indices_map[j]) expanded[A.cols[idx]] += 1;</div>
<div class="line"><span class="lineno">  176</span>                for (int idx : row_indices_map[k]) expanded[A.cols[idx]] += 1;</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span>                <span class="comment">// Accumulate LHS cut values</span></div>
<div class="line"><span class="lineno">  179</span>                for (int idx = 0; idx &lt; A.num_cols; ++idx) {</div>
<div class="line"><span class="lineno">  180</span>                    if (expanded[idx] &gt;= 2) {</div>
<div class="line"><span class="lineno">  181</span>                        lhs += std::floor(expanded[idx] * 0.5) * x[idx];</div>
<div class="line"><span class="lineno">  182</span>                        buffer_int[buffer_int_n++] = idx;</div>
<div class="line"><span class="lineno">  183</span>                    }</div>
<div class="line"><span class="lineno">  184</span>                }</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>                <span class="comment">// If lhs violation found, insert the cut</span></div>
<div class="line"><span class="lineno">  187</span>                if (lhs &gt; 1.0 + 1e-3) {</div>
<div class="line"><span class="lineno">  188</span><span class="comment">// print lhs</span></div>
<div class="line"><span class="lineno">  189</span>#ifdef NSYNC</div>
<div class="line"><span class="lineno">  190</span>                    nsync::nsync_mu_lock(&amp;cuts_mutex);</div>
<div class="line"><span class="lineno">  191</span>#else</div>
<div class="line"><span class="lineno">  192</span>                    std::lock_guard&lt;std::mutex&gt; lock(cuts_mutex);</div>
<div class="line"><span class="lineno">  193</span>#endif</div>
<div class="line"><span class="lineno">  194</span>                    insertSet(cuts, i, j, k, buffer_int, buffer_int_n, lhs);</div>
<div class="line"><span class="lineno">  195</span>#ifdef NSYNC</div>
<div class="line"><span class="lineno">  196</span>                    nsync::nsync_mu_unlock(&amp;cuts_mutex);</div>
<div class="line"><span class="lineno">  197</span>#endif</div>
<div class="line"><span class="lineno">  198</span>                }</div>
<div class="line"><span class="lineno">  199</span>            }</div>
<div class="line"><span class="lineno">  200</span>        });</div>
<div class="line"><span class="lineno">  201</span> </div>
<div class="line"><span class="lineno">  202</span>    <span class="comment">// Submit work to the thread pool</span></div>
<div class="line"><span class="lineno">  203</span>    <span class="keyword">auto</span> work = stdexec::starts_on(sched, bulk_sender);</div>
<div class="line"><span class="lineno">  204</span>    stdexec::sync_wait(std::move(work));</div>
<div class="line"><span class="lineno">  205</span> </div>
<div class="line"><span class="lineno">  206</span>    <span class="comment">// Generate cut coefficients</span></div>
<div class="line"><span class="lineno">  207</span>    std::vector&lt;std::vector&lt;double&gt;&gt; coefficients;</div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordflow">if</span> (cuts.S_n &gt; 0) { <a class="code hl_function" href="#a6a3630f3c02917789164102d02fc4768">generateCutCoefficients</a>(cuts, coefficients, A.<a class="code hl_variable" href="structSparseMatrix.html#aa5036f289fb33d08420b8429acb68514">num_cols</a>, A, x); }</div>
<div class="line"><span class="lineno">  209</span>    cuts.S.resize(cuts.S_n + 1);</div>
<div class="line"><span class="lineno">  210</span>    cuts.S[cuts.S_n] = cuts.S_C_P.size();</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span>    <span class="keywordflow">return</span> coefficients;</div>
<div class="line"><span class="lineno">  213</span>}</div>
<div class="ttc" id="aSRC_8h_html_a9ed98a20ad5b3389f821d145e4fee5ea"><div class="ttname"><a href="SRC_8h.html#a9ed98a20ad5b3389f821d145e4fee5ea">VRPTW_SRC_max_S_n</a></div><div class="ttdeci">#define VRPTW_SRC_max_S_n</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00046">SRC.h:46</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a6a3630f3c02917789164102d02fc4768"><div class="ttname"><a href="#a6a3630f3c02917789164102d02fc4768">LimitedMemoryRank1Cuts::generateCutCoefficients</a></div><div class="ttdeci">void generateCutCoefficients(VRPTW_SRC &amp;cuts, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;coefficients, int numNodes, const SparseMatrix &amp;A, const std::vector&lt; double &gt; &amp;x)</div><div class="ttdoc">Generates cut coefficients for the given VRPTW_SRC cuts.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8cpp_source.html#l00265">SRC.cpp:265</a></div></div>
<div class="ttc" id="astructSparseMatrix_html_a0e1b1a48ae0246c841fcc0cd301ca940"><div class="ttname"><a href="structSparseMatrix.html#a0e1b1a48ae0246c841fcc0cd301ca940">SparseMatrix::rows</a></div><div class="ttdeci">std::vector&lt; int &gt; rows</div><div class="ttdef"><b>Definition</b> <a href="SparseMatrix_8h_source.html#l00015">SparseMatrix.h:15</a></div></div>
<div class="ttc" id="astructSparseMatrix_html_aa5036f289fb33d08420b8429acb68514"><div class="ttname"><a href="structSparseMatrix.html#aa5036f289fb33d08420b8429acb68514">SparseMatrix::num_cols</a></div><div class="ttdeci">int num_cols</div><div class="ttdef"><b>Definition</b> <a href="SparseMatrix_8h_source.html#l00026">SparseMatrix.h:26</a></div></div>
<div class="ttc" id="astructSparseMatrix_html_accda920bb43c45ca83da3cc8c7ad4561"><div class="ttname"><a href="structSparseMatrix.html#accda920bb43c45ca83da3cc8c7ad4561">SparseMatrix::values</a></div><div class="ttdeci">std::vector&lt; double &gt; values</div><div class="ttdef"><b>Definition</b> <a href="SparseMatrix_8h_source.html#l00017">SparseMatrix.h:17</a></div></div>
<div class="ttc" id="astructVRPTW__SRC_html"><div class="ttname"><a href="structVRPTW__SRC.html">VRPTW_SRC</a></div><div class="ttdoc">A structure to represent the Vehicle Routing Problem with Time Windows (VRPTW) source data.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00061">SRC.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b3eba87af98185081086c5f5b34c5ce" name="a7b3eba87af98185081086c5f5b34c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3eba87af98185081086c5f5b34c5ce">&#9670;&#160;</a></span>the45Heuristic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425f">CutType</a> T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LimitedMemoryRank1Cuts::the45Heuristic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSparseMatrix.html">SparseMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the 45 Heuristic for generating limited memory rank-1 cuts. </p>
<p>This function generates limited memory rank-1 cuts using a heuristic approach. It processes sets of customers and permutations to identify violations and generate cuts. The function is parallelized to improve efficiency. </p>

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00321">321</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  321</span>                                                                                             {</div>
<div class="line"><span class="lineno">  322</span>    <span class="keywordtype">int</span>    max_number_of_cuts  = 10; <span class="comment">// Max number of cuts to generate</span></div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordtype">double</span> violation_threshold = 1e-3;</div>
<div class="line"><span class="lineno">  324</span>    <span class="keywordtype">int</span>    max_generated_cuts  = 15;</div>
<div class="line"><span class="lineno">  325</span> </div>
<div class="line"><span class="lineno">  326</span>    <span class="keyword">auto</span> &amp;selectedNodes = <a class="code hl_variable" href="#afd9fbfe139aabbb019ed099c0b485f5c">the45selectedNodes</a>;</div>
<div class="line"><span class="lineno">  327</span>    <span class="comment">// Ensure selectedNodes is valid</span></div>
<div class="line"><span class="lineno">  328</span> </div>
<div class="line"><span class="lineno">  329</span>    std::vector&lt;SRCPermutation&gt; permutations;</div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (T == <a class="code hl_enumvalue" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa11644190d0aa82e0784bd5b8a9530d03">CutType::FourRow</a>) {</div>
<div class="line"><span class="lineno">  331</span>        permutations = <a class="code hl_function" href="SRC_8h.html#abd5d9a806975ce95efb3b8ce3e6fe2e5">getPermutationsForSize4</a>();</div>
<div class="line"><span class="lineno">  332</span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (T == <a class="code hl_enumvalue" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa4c5d066c0fda7499381bc409dd736b70">CutType::FiveRow</a>) {</div>
<div class="line"><span class="lineno">  333</span>        permutations = <a class="code hl_function" href="SRC_8h.html#a0ec7e413b362fcfa33e475b88198ff9b">getPermutationsForSize5</a>();</div>
<div class="line"><span class="lineno">  334</span>    }</div>
<div class="line"><span class="lineno">  335</span> </div>
<div class="line"><span class="lineno">  336</span>    <span class="comment">// Shuffle permutations and limit to 3 for efficiency</span></div>
<div class="line"><span class="lineno">  337</span>    <span class="comment">// int seed = std::chrono::system_clock::now().time_since_epoch().count(); // Use current time as a seed</span></div>
<div class="line"><span class="lineno">  338</span> </div>
<div class="line"><span class="lineno">  339</span>    <a class="code hl_class" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a> rng; <span class="comment">// Seed it (you can change the seed)</span></div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordflow">if</span> (permutations.size() &gt; 4) {</div>
<div class="line"><span class="lineno">  341</span>        <span class="comment">// Use std::shuffle with the Xoroshiro128Plus generator</span></div>
<div class="line"><span class="lineno">  342</span>        permutations.resize(4);</div>
<div class="line"><span class="lineno">  343</span>    }</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span>    ankerl::unordered_dense::set&lt;uint64_t&gt; processedSetsCache;</div>
<div class="line"><span class="lineno">  346</span>    ankerl::unordered_dense::set&lt;uint64_t&gt; processedPermutationsCache;</div>
<div class="line"><span class="lineno">  347</span>    std::atomic&lt;int&gt;                       cuts_count(0); <span class="comment">// Thread-safe counter for cuts</span></div>
<div class="line"><span class="lineno">  348</span> </div>
<div class="line"><span class="lineno">  349</span>    <span class="comment">// Create tasks for each selected node to parallelize</span></div>
<div class="line"><span class="lineno">  350</span>    std::vector&lt;int&gt; tasks(selectedNodes.size());</div>
<div class="line"><span class="lineno">  351</span>    std::iota(tasks.begin(), tasks.end(), 0); <span class="comment">// Filling tasks with indices 0 to selectedNodes.size()</span></div>
<div class="line"><span class="lineno">  352</span> </div>
<div class="line"><span class="lineno">  353</span>    exec::static_thread_pool pool(std::thread::hardware_concurrency());</div>
<div class="line"><span class="lineno">  354</span>    <span class="keyword">auto</span>                     sched = pool.get_scheduler();</div>
<div class="line"><span class="lineno">  355</span> </div>
<div class="line"><span class="lineno">  356</span>    <span class="keyword">auto</span> input_sender = stdexec::just();</div>
<div class="line"><span class="lineno">  357</span><span class="preprocessor">#ifdef NSYNC</span></div>
<div class="line"><span class="lineno">  358</span>    nsync::nsync_mu cuts_mutex = NSYNC_MU_INIT;</div>
<div class="line"><span class="lineno">  359</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  360</span>    std::mutex cuts_mutex; <span class="comment">// Protect access to shared resources</span></div>
<div class="line"><span class="lineno">  361</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  362</span>    <a class="code hl_typedef" href="#a079bd845ca33bdfc18be9e392626acc0">CutPriorityQueue</a> cutQueue;</div>
<div class="line"><span class="lineno">  363</span>    <span class="keyword">auto</span>            &amp;cutCache = (T == <a class="code hl_enumvalue" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa11644190d0aa82e0784bd5b8a9530d03">CutType::FourRow</a>) ? <a class="code hl_variable" href="#a9ee64e3c2c61461ce2755bfa73f7697b">cutCache4</a> : <a class="code hl_variable" href="#ade7540a903f5c7b58271db330f0013d6">cutCache5</a>;</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>    std::vector&lt;double&gt;                            coefficients_aux(<a class="code hl_variable" href="#aaad518dd2434c218df7e9283238a6577">allPaths</a>.size(), 0.0);</div>
<div class="line"><span class="lineno">  366</span>    std::vector&lt;std::tuple&lt;int, std::vector&lt;int&gt;&gt;&gt; task_data; <span class="comment">// To hold task_id and setsOf45 for each task</span></div>
<div class="line"><span class="lineno">  367</span> </div>
<div class="line"><span class="lineno">  368</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> chunk_size = 10; <span class="comment">// Adjust chunk size based on performance experiments</span></div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>    <span class="comment">// Emplace tasks and prepare setsOf45 for each task</span></div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> task_id : tasks) {</div>
<div class="line"><span class="lineno">  372</span>        <span class="keyword">auto</span> &amp;consumer = <a class="code hl_variable" href="#aaad518dd2434c218df7e9283238a6577">allPaths</a>[selectedNodes[task_id]].route;</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (T == <a class="code hl_enumvalue" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa11644190d0aa82e0784bd5b8a9530d03">CutType::FourRow</a>) {</div>
<div class="line"><span class="lineno">  375</span>            <span class="keywordflow">if</span> (consumer.size() &lt; 4) { <span class="keywordflow">continue</span>; } <span class="comment">// Skip if not enough elements for CutType::FourRow</span></div>
<div class="line"><span class="lineno">  376</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (T == <a class="code hl_enumvalue" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa4c5d066c0fda7499381bc409dd736b70">CutType::FiveRow</a>) {</div>
<div class="line"><span class="lineno">  377</span>            <span class="keywordflow">if</span> (consumer.size() &lt; 5) { <span class="keywordflow">continue</span>; } <span class="comment">// Skip if not enough elements for CutType::FiveRow</span></div>
<div class="line"><span class="lineno">  378</span>        }</div>
<div class="line"><span class="lineno">  379</span> </div>
<div class="line"><span class="lineno">  380</span>        std::vector&lt;std::vector&lt;int&gt;&gt; setsOf45;</div>
<div class="line"><span class="lineno">  381</span> </div>
<div class="line"><span class="lineno">  382</span>        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (T == <a class="code hl_enumvalue" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa11644190d0aa82e0784bd5b8a9530d03">CutType::FourRow</a>) {</div>
<div class="line"><span class="lineno">  383</span>            <a class="code hl_function" href="SRC_8h.html#ac1e86f60f149c469a628f58f3e595221">combinations</a>(consumer, 4, 10, setsOf45);</div>
<div class="line"><span class="lineno">  384</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (T == <a class="code hl_enumvalue" href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa4c5d066c0fda7499381bc409dd736b70">CutType::FiveRow</a>) {</div>
<div class="line"><span class="lineno">  385</span>            <a class="code hl_function" href="SRC_8h.html#ac1e86f60f149c469a628f58f3e595221">combinations</a>(consumer, 5, 10, setsOf45);</div>
<div class="line"><span class="lineno">  386</span>        }</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> set45 : setsOf45) {</div>
<div class="line"><span class="lineno">  389</span>            <span class="comment">// Emplace the task id and its setsOf45 into the task_data vector</span></div>
<div class="line"><span class="lineno">  390</span>            task_data.emplace_back(task_id, set45);</div>
<div class="line"><span class="lineno">  391</span>        }</div>
<div class="line"><span class="lineno">  392</span>    }</div>
<div class="line"><span class="lineno">  393</span> </div>
<div class="line"><span class="lineno">  394</span>    <span class="comment">// Parallel processing for setsOf45</span></div>
<div class="line"><span class="lineno">  395</span>    <span class="keyword">auto</span> bulk_sender = stdexec::bulk(</div>
<div class="line"><span class="lineno">  396</span>        stdexec::just(), (task_data.size() + chunk_size - 1) / chunk_size, <span class="comment">// Calculate number of chunks</span></div>
<div class="line"><span class="lineno">  397</span>        [<span class="keyword">this</span>, &amp;permutations, &amp;processedSetsCache, &amp;processedPermutationsCache, &amp;cuts_mutex, &amp;x, &amp;selectedNodes,</div>
<div class="line"><span class="lineno">  398</span>         &amp;cutQueue, &amp;max_number_of_cuts, &amp;max_generated_cuts, violation_threshold, &amp;task_data,</div>
<div class="line"><span class="lineno">  399</span>         &amp;cuts_count](std::size_t chunk_idx) {</div>
<div class="line"><span class="lineno">  400</span>            <span class="comment">// Calculate the start and end index for this chunk</span></div>
<div class="line"><span class="lineno">  401</span>            size_t           start_idx = chunk_idx * chunk_size;</div>
<div class="line"><span class="lineno">  402</span>            size_t           end_idx   = std::min(start_idx + chunk_size, task_data.size());</div>
<div class="line"><span class="lineno">  403</span>            Xoroshiro128Plus rng; <span class="comment">// Seed it (you can change the seed)</span></div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>            <span class="comment">// Process each task in the chunk</span></div>
<div class="line"><span class="lineno">  406</span>            for (size_t idx = start_idx; idx &lt; end_idx; ++idx) {</div>
<div class="line"><span class="lineno">  407</span>                auto [task_id, set45] = task_data[idx];</div>
<div class="line"><span class="lineno">  408</span>                std::vector&lt;double&gt; coefficients_aux(allPaths.size(), 0.0);</div>
<div class="line"><span class="lineno">  409</span> </div>
<div class="line"><span class="lineno">  410</span>                uint64_t setHash = hashVector(set45);</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span>                {</div>
<div class="line"><span class="lineno">  413</span>                    std::lock_guard&lt;std::mutex&gt; cache_lock(cuts_mutex);</div>
<div class="line"><span class="lineno">  414</span>                    if (processedSetsCache.find(setHash) != processedSetsCache.end()) {</div>
<div class="line"><span class="lineno">  415</span>                        return; <span class="comment">// Skip already processed sets</span></div>
<div class="line"><span class="lineno">  416</span>                    }</div>
<div class="line"><span class="lineno">  417</span>                    processedSetsCache.insert(setHash);</div>
<div class="line"><span class="lineno">  418</span>                }</div>
<div class="line"><span class="lineno">  419</span>                std::array&lt;uint64_t, num_words&gt; AM      = {};</div>
<div class="line"><span class="lineno">  420</span>                std::array&lt;uint64_t, num_words&gt; baseSet = {};</div>
<div class="line"><span class="lineno">  421</span>                std::vector&lt;int&gt;                order(N_SIZE, 0);</div>
<div class="line"><span class="lineno">  422</span> </div>
<div class="line"><span class="lineno">  423</span>                for (const auto &amp;p : permutations) {</div>
<div class="line"><span class="lineno">  424</span>                    auto p_cat = p.num;</div>
<div class="line"><span class="lineno">  425</span>                    p_cat.push_back(p.den);</div>
<div class="line"><span class="lineno">  426</span>                    uint64_t pHash = hashVector(p_cat);</div>
<div class="line"><span class="lineno">  427</span>                    <span class="comment">// concatenate processed set and permutation</span></div>
<div class="line"><span class="lineno">  428</span>                    uint64_t setPermutationHash = setHash ^ pHash;</div>
<div class="line"><span class="lineno">  429</span> </div>
<div class="line"><span class="lineno">  430</span>                    {</div>
<div class="line"><span class="lineno">  431</span>                        std::lock_guard&lt;std::mutex&gt; cache_lock(cuts_mutex);</div>
<div class="line"><span class="lineno">  432</span>                        if (processedPermutationsCache.find(setPermutationHash) != processedPermutationsCache.end()) {</div>
<div class="line"><span class="lineno">  433</span>                            continue; <span class="comment">// Skip already processed permutations</span></div>
<div class="line"><span class="lineno">  434</span>                        }</div>
<div class="line"><span class="lineno">  435</span>                        processedPermutationsCache.insert(setPermutationHash);</div>
<div class="line"><span class="lineno">  436</span>                    }</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span>                    AM.fill(0);</div>
<div class="line"><span class="lineno">  439</span>                    baseSet.fill(0);</div>
<div class="line"><span class="lineno">  440</span>                    std::fill(order.begin(), order.end(), 0);</div>
<div class="line"><span class="lineno">  441</span> </div>
<div class="line"><span class="lineno">  442</span>                    for (auto c : set45) { baseSet[c &gt;&gt; 6] |= (1ULL &lt;&lt; (c &amp; 63)); }</div>
<div class="line"><span class="lineno">  443</span>                    int ordering = 0;</div>
<div class="line"><span class="lineno">  444</span>                    for (auto node : set45) {</div>
<div class="line"><span class="lineno">  445</span>                        AM[node &gt;&gt; 6] |= (1ULL &lt;&lt; (node &amp; 63)); <span class="comment">// Set the bit for node in AM</span></div>
<div class="line"><span class="lineno">  446</span>                        order[node] = ordering++;</div>
<div class="line"><span class="lineno">  447</span>                    }</div>
<div class="line"><span class="lineno">  448</span> </div>
<div class="line"><span class="lineno">  449</span>                    std::fill(coefficients_aux.begin(), coefficients_aux.end(), 0.0);</div>
<div class="line"><span class="lineno">  450</span>                    int    rhs             = p.getRHS();</div>
<div class="line"><span class="lineno">  451</span>                    double alpha           = 0;</div>
<div class="line"><span class="lineno">  452</span>                    bool   violation_found = false;</div>
<div class="line"><span class="lineno">  453</span> </div>
<div class="line"><span class="lineno">  454</span>                    for (auto j = 0; j &lt; selectedNodes.size(); ++j) {</div>
<div class="line"><span class="lineno">  455</span>                        <span class="comment">// if (selectedNodes[j] == selectedNodes[task_idx]) {}</span></div>
<div class="line"><span class="lineno">  456</span>                        auto &amp;consumer_inner = allPaths[selectedNodes[j]].route;</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>                        int max_limit = (T == CutType::FourRow) ? 3 : 4;</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>                        int match_count = 0;</div>
<div class="line"><span class="lineno">  461</span>                        for (auto &amp;node : set45) {</div>
<div class="line"><span class="lineno">  462</span>                            if (std::ranges::find(consumer_inner, node) != consumer_inner.end()) {</div>
<div class="line"><span class="lineno">  463</span>                                if (++match_count == max_limit) { break; }</div>
<div class="line"><span class="lineno">  464</span>                            }</div>
<div class="line"><span class="lineno">  465</span>                        }</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span>                        if (match_count &lt; max_limit) continue;</div>
<div class="line"><span class="lineno">  468</span>                        for (auto c : consumer_inner) { AM[c &gt;&gt; 6] |= (1ULL &lt;&lt; (c &amp; 63)); }</div>
<div class="line"><span class="lineno">  469</span>                        double alpha_inner = computeLimitedMemoryCoefficient(baseSet, AM, p, consumer_inner, order);</div>
<div class="line"><span class="lineno">  470</span>                        alpha += alpha_inner;</div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>                        coefficients_aux[selectedNodes[j]] = alpha_inner;</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span>                        if (alpha &gt; rhs + violation_threshold) { violation_found = true; }</div>
<div class="line"><span class="lineno">  475</span> </div>
<div class="line"><span class="lineno">  476</span>                        if (violation_found) {</div>
<div class="line"><span class="lineno">  477</span>                            std::bitset&lt;N_SIZE&gt; minimal_bitset;</div>
<div class="line"><span class="lineno">  478</span> </div>
<div class="line"><span class="lineno">  479</span>                            <span class="comment">// Function to check if removing a set of nodes still results in a violation</span></div>
<div class="line"><span class="lineno">  480</span>                            auto is_violation = [&amp;](const std::bitset&lt;N_SIZE&gt; &amp;removal_set) -&gt; bool {</div>
<div class="line"><span class="lineno">  481</span>                                std::array&lt;uint64_t, num_words&gt; tempAM = AM; <span class="comment">// Use direct initialization</span></div>
<div class="line"><span class="lineno">  482</span> </div>
<div class="line"><span class="lineno">  483</span>                                <span class="comment">// Temporarily remove all nodes in removal_set from tempAM</span></div>
<div class="line"><span class="lineno">  484</span>                                for (int i = 0; i &lt; N_SIZE; ++i) {</div>
<div class="line"><span class="lineno">  485</span>                                    if (removal_set[i]) {</div>
<div class="line"><span class="lineno">  486</span>                                        tempAM[i &gt;&gt; 6] &amp;= ~(1ULL &lt;&lt; (i &amp; 63)); <span class="comment">// Use bit operations to unset nodes</span></div>
<div class="line"><span class="lineno">  487</span>                                    }</div>
<div class="line"><span class="lineno">  488</span>                                }</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>                                <span class="comment">// Recalculate alpha with the modified tempAM, introduce early exit</span></div>
<div class="line"><span class="lineno">  491</span>                                double reduced_alpha = 0;</div>
<div class="line"><span class="lineno">  492</span>                                for (const auto &amp;selected_node : selectedNodes) {</div>
<div class="line"><span class="lineno">  493</span>                                    const auto &amp;consumer_inner = allPaths[selected_node].route;</div>
<div class="line"><span class="lineno">  494</span>                                    reduced_alpha +=</div>
<div class="line"><span class="lineno">  495</span>                                        computeLimitedMemoryCoefficient(baseSet, tempAM, p, consumer_inner, order);</div>
<div class="line"><span class="lineno">  496</span>                                    if (reduced_alpha &gt; rhs + violation_threshold) { <span class="comment">// Early exit</span></div>
<div class="line"><span class="lineno">  497</span>                                        return true;</div>
<div class="line"><span class="lineno">  498</span>                                    }</div>
<div class="line"><span class="lineno">  499</span>                                }</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span>                                return (reduced_alpha &gt; rhs + violation_threshold);</div>
<div class="line"><span class="lineno">  502</span>                            };</div>
<div class="line"><span class="lineno">  503</span> </div>
<div class="line"><span class="lineno">  504</span>                            <span class="comment">// Function to find the minimal violating set using genetic algorithm</span></div>
<div class="line"><span class="lineno">  505</span>                            auto find_minimal_violation_set =</div>
<div class="line"><span class="lineno">  506</span>                                [&amp;](std::bitset&lt;N_SIZE&gt; &amp;current_bitset) -&gt; std::bitset&lt;N_SIZE&gt; {</div>
<div class="line"><span class="lineno">  507</span>                                std::bitset&lt;N_SIZE&gt; minimal_bitset = current_bitset;</div>
<div class="line"><span class="lineno">  508</span> </div>
<div class="line"><span class="lineno">  509</span>                                int    population_size = 10;  <span class="comment">// Number of candidates in each generation</span></div>
<div class="line"><span class="lineno">  510</span>                                int    max_generations = 5;   <span class="comment">// Number of generations</span></div>
<div class="line"><span class="lineno">  511</span>                                double mutation_rate   = 0.3; <span class="comment">// Probability of mutating a bit</span></div>
<div class="line"><span class="lineno">  512</span>                                std::vector&lt;std::bitset&lt;N_SIZE&gt;&gt; population;</div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span>                                int mutationCandidate = N_SIZE / 10; <span class="comment">// Number of mutations in each candidate</span></div>
<div class="line"><span class="lineno">  515</span>                                <span class="comment">// Initialize the population with random mutations of the current bitset</span></div>
<div class="line"><span class="lineno">  516</span>                                for (int i = 0; i &lt; population_size; ++i) {</div>
<div class="line"><span class="lineno">  517</span>                                    std::bitset&lt;N_SIZE&gt; candidate = current_bitset;</div>
<div class="line"><span class="lineno">  518</span>                                    for (int j = 0; j &lt; mutationCandidate; ++j) {</div>
<div class="line"><span class="lineno">  519</span>                                        auto bit = rng() % N_SIZE;</div>
<div class="line"><span class="lineno">  520</span>                                        if ((rng() / double(RAND_MAX)) &lt; mutation_rate) {</div>
<div class="line"><span class="lineno">  521</span>                                            candidate.reset(bit); <span class="comment">// Mutate: remove random nodes</span></div>
<div class="line"><span class="lineno">  522</span>                                        }</div>
<div class="line"><span class="lineno">  523</span>                                    }</div>
<div class="line"><span class="lineno">  524</span>                                    population.push_back(candidate);</div>
<div class="line"><span class="lineno">  525</span>                                }</div>
<div class="line"><span class="lineno">  526</span> </div>
<div class="line"><span class="lineno">  527</span>                                <span class="comment">// Main loop for genetic algorithm generations</span></div>
<div class="line"><span class="lineno">  528</span>                                for (int gen = 0; gen &lt; max_generations; ++gen) {</div>
<div class="line"><span class="lineno">  529</span>                                    <span class="comment">// Evaluate the population and store fitness (whether it causes a violation)</span></div>
<div class="line"><span class="lineno">  530</span>                                    std::vector&lt;std::pair&lt;std::bitset&lt;N_SIZE&gt;, bool&gt;&gt; evaluated_population;</div>
<div class="line"><span class="lineno">  531</span>                                    for (auto &amp;candidate : population) {</div>
<div class="line"><span class="lineno">  532</span>                                        evaluated_population.push_back({candidate, is_violation(candidate)});</div>
<div class="line"><span class="lineno">  533</span>                                    }</div>
<div class="line"><span class="lineno">  534</span> </div>
<div class="line"><span class="lineno">  535</span>                                    <span class="comment">// Select the best candidate from the population (the one that still violates)</span></div>
<div class="line"><span class="lineno">  536</span>                                    pdqsort(evaluated_population.begin(), evaluated_population.end(),</div>
<div class="line"><span class="lineno">  537</span>                                            [](const auto &amp;lhs, const auto &amp;rhs) { return lhs.second &lt; rhs.second; });</div>
<div class="line"><span class="lineno">  538</span>                                    minimal_bitset = evaluated_population.front().first;</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>                                    <span class="comment">// Perform crossover (combine two parents) to generate new population</span></div>
<div class="line"><span class="lineno">  541</span>                                    std::vector&lt;std::bitset&lt;N_SIZE&gt;&gt; new_population;</div>
<div class="line"><span class="lineno">  542</span>                                    for (int i = 0; i &lt; population_size / 2; ++i) {</div>
<div class="line"><span class="lineno">  543</span>                                        std::bitset&lt;N_SIZE&gt; parent1 = evaluated_population[i].first;</div>
<div class="line"><span class="lineno">  544</span>                                        std::bitset&lt;N_SIZE&gt; parent2 = evaluated_population[i + 1].first;</div>
<div class="line"><span class="lineno">  545</span>                                        std::bitset&lt;N_SIZE&gt; child1, child2;</div>
<div class="line"><span class="lineno">  546</span> </div>
<div class="line"><span class="lineno">  547</span>                                        <span class="comment">// Crossover: mix bits from two parents</span></div>
<div class="line"><span class="lineno">  548</span>                                        for (int j = 0; j &lt; N_SIZE; ++j) {</div>
<div class="line"><span class="lineno">  549</span>                                            if (rng() % 2) {</div>
<div class="line"><span class="lineno">  550</span>                                                child1[j] = parent1[j];</div>
<div class="line"><span class="lineno">  551</span>                                                child2[j] = parent2[j];</div>
<div class="line"><span class="lineno">  552</span>                                            } else {</div>
<div class="line"><span class="lineno">  553</span>                                                child1[j] = parent2[j];</div>
<div class="line"><span class="lineno">  554</span>                                                child2[j] = parent1[j];</div>
<div class="line"><span class="lineno">  555</span>                                            }</div>
<div class="line"><span class="lineno">  556</span>                                        }</div>
<div class="line"><span class="lineno">  557</span> </div>
<div class="line"><span class="lineno">  558</span>                                        <span class="comment">// Mutate the children</span></div>
<div class="line"><span class="lineno">  559</span>                                        for (int j = 0; j &lt; N_SIZE; ++j) {</div>
<div class="line"><span class="lineno">  560</span>                                            if ((rand() / double(RAND_MAX)) &lt; mutation_rate) {</div>
<div class="line"><span class="lineno">  561</span>                                                child1.reset(j); <span class="comment">// Mutate: remove random nodes</span></div>
<div class="line"><span class="lineno">  562</span>                                            }</div>
<div class="line"><span class="lineno">  563</span>                                            if ((rand() / double(RAND_MAX)) &lt; mutation_rate) {</div>
<div class="line"><span class="lineno">  564</span>                                                child2.reset(j); <span class="comment">// Mutate: remove random nodes</span></div>
<div class="line"><span class="lineno">  565</span>                                            }</div>
<div class="line"><span class="lineno">  566</span>                                        }</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>                                        <span class="comment">// Add children to the new population</span></div>
<div class="line"><span class="lineno">  569</span>                                        new_population.push_back(child1);</div>
<div class="line"><span class="lineno">  570</span>                                        new_population.push_back(child2);</div>
<div class="line"><span class="lineno">  571</span>                                    }</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span>                                    <span class="comment">// Replace the old population with the new one</span></div>
<div class="line"><span class="lineno">  574</span>                                    population = new_population;</div>
<div class="line"><span class="lineno">  575</span>                                }</div>
<div class="line"><span class="lineno">  576</span> </div>
<div class="line"><span class="lineno">  577</span>                                return minimal_bitset;</div>
<div class="line"><span class="lineno">  578</span>                            };</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span>                            <span class="comment">// Build the initial set of nodes not in baseSet but in AM</span></div>
<div class="line"><span class="lineno">  581</span>                            std::bitset&lt;N_SIZE&gt; current_bitset;</div>
<div class="line"><span class="lineno">  582</span>                            for (int i = 1; i &lt; N_SIZE - 2; ++i) {</div>
<div class="line"><span class="lineno">  583</span>                                if (!(baseSet[i &gt;&gt; 6] &amp; (1ULL &lt;&lt; (i &amp; 63))) &amp;&amp; (AM[i &gt;&gt; 6] &amp; (1ULL &lt;&lt; (i &amp; 63)))) {</div>
<div class="line"><span class="lineno">  584</span>                                    current_bitset.set(i);</div>
<div class="line"><span class="lineno">  585</span>                                }</div>
<div class="line"><span class="lineno">  586</span>                            }</div>
<div class="line"><span class="lineno">  587</span> </div>
<div class="line"><span class="lineno">  588</span>                            <span class="comment">// Find the minimal violating set using simulated annealing</span></div>
<div class="line"><span class="lineno">  589</span>                            std::bitset&lt;N_SIZE&gt; minimalSet = find_minimal_violation_set(current_bitset);</div>
<div class="line"><span class="lineno">  590</span> </div>
<div class="line"><span class="lineno">  591</span>                            <span class="comment">// Apply the minimal set to adjust AM</span></div>
<div class="line"><span class="lineno">  592</span>                            for (int i = 0; i &lt; N_SIZE; ++i) {</div>
<div class="line"><span class="lineno">  593</span>                                if (!minimalSet[i]) {</div>
<div class="line"><span class="lineno">  594</span>                                    AM[i &gt;&gt; 6] &amp;= ~(1ULL &lt;&lt; (i &amp; 63)); <span class="comment">// Clear bit if i not in minimalSet</span></div>
<div class="line"><span class="lineno">  595</span>                                } else {</div>
<div class="line"><span class="lineno">  596</span>                                    AM[i &gt;&gt; 6] |= (1ULL &lt;&lt; (i &amp; 63)); <span class="comment">// Set bit if i in minimalSet</span></div>
<div class="line"><span class="lineno">  597</span>                                }</div>
<div class="line"><span class="lineno">  598</span>                            }</div>
<div class="line"><span class="lineno">  599</span> </div>
<div class="line"><span class="lineno">  600</span>                            <span class="comment">// Recalculate alpha after applying the minimal set of nodes</span></div>
<div class="line"><span class="lineno">  601</span>                            alpha = 0;</div>
<div class="line"><span class="lineno">  602</span>                            for (auto j = 0; j &lt; selectedNodes.size(); ++j) {</div>
<div class="line"><span class="lineno">  603</span>                                const auto &amp;consumer_inner = allPaths[selectedNodes[j]].route;</div>
<div class="line"><span class="lineno">  604</span>                                alpha += computeLimitedMemoryCoefficient(baseSet, AM, p, consumer_inner, order);</div>
<div class="line"><span class="lineno">  605</span>                            }</div>
<div class="line"><span class="lineno">  606</span> </div>
<div class="line"><span class="lineno">  607</span>                            <span class="comment">// compute coefficients_aux for all the other nodes</span></div>
<div class="line"><span class="lineno">  608</span>                            for (auto k = 0; k &lt; allPaths.size(); k++) {</div>
<div class="line"><span class="lineno">  609</span>                                if (k == selectedNodes[j]) continue;</div>
<div class="line"><span class="lineno">  610</span>                                auto &amp;consumer_inner = allPaths[k];</div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>                                int max_limit = 0;</div>
<div class="line"><span class="lineno">  613</span>                                if constexpr (T == CutType::FourRow) {</div>
<div class="line"><span class="lineno">  614</span>                                    max_limit = 3;</div>
<div class="line"><span class="lineno">  615</span>                                } else if constexpr (T == CutType::FiveRow) {</div>
<div class="line"><span class="lineno">  616</span>                                    max_limit = 4;</div>
<div class="line"><span class="lineno">  617</span>                                }</div>
<div class="line"><span class="lineno">  618</span>                                int match_count = 0;</div>
<div class="line"><span class="lineno">  619</span>                                for (auto &amp;node : set45) {</div>
<div class="line"><span class="lineno">  620</span>                                    if (std::ranges::find(consumer_inner, node) != consumer_inner.end()) {</div>
<div class="line"><span class="lineno">  621</span>                                        if (++match_count == max_limit) { break; }</div>
<div class="line"><span class="lineno">  622</span>                                    }</div>
<div class="line"><span class="lineno">  623</span>                                }</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span>                                if (match_count &lt; max_limit) continue;</div>
<div class="line"><span class="lineno">  626</span> </div>
<div class="line"><span class="lineno">  627</span>                                std::vector&lt;int&gt; thePath(consumer_inner.begin(), consumer_inner.end());</div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="line"><span class="lineno">  629</span>                                double alpha_inner  = computeLimitedMemoryCoefficient(baseSet, AM, p, thePath, order);</div>
<div class="line"><span class="lineno">  630</span>                                coefficients_aux[k] = alpha_inner;</div>
<div class="line"><span class="lineno">  631</span>                            }</div>
<div class="line"><span class="lineno">  632</span> </div>
<div class="line"><span class="lineno">  633</span>                            Cut cut(baseSet, AM, coefficients_aux, p);</div>
<div class="line"><span class="lineno">  634</span>                            cut.baseSetOrder = order;</div>
<div class="line"><span class="lineno">  635</span>                            cut.rhs          = rhs;</div>
<div class="line"><span class="lineno">  636</span> </div>
<div class="line"><span class="lineno">  637</span>                            ViolatedCut vCut{alpha, cut}; <span class="comment">// Pair: first is the violation, second is the cut</span></div>
<div class="line"><span class="lineno">  638</span>#ifndef NSYNC</div>
<div class="line"><span class="lineno">  639</span>                            std::lock_guard&lt;std::mutex&gt; cut_lock(cuts_mutex);</div>
<div class="line"><span class="lineno">  640</span>#endif</div>
<div class="line"><span class="lineno">  641</span>                            {</div>
<div class="line"><span class="lineno">  642</span>#ifdef NSYNC</div>
<div class="line"><span class="lineno">  643</span>                                nsync::nsync_mu_lock(&amp;cuts_mutex);</div>
<div class="line"><span class="lineno">  644</span>#endif</div>
<div class="line"><span class="lineno">  645</span>                                if (cutQueue.size() &lt; max_number_of_cuts) {</div>
<div class="line"><span class="lineno">  646</span>                                    cutQueue.push(vCut);</div>
<div class="line"><span class="lineno">  647</span>                                } else if (cutQueue.top().first &lt; vCut.first) { <span class="comment">// Compare violations</span></div>
<div class="line"><span class="lineno">  648</span>                                    cutQueue.pop();                             <span class="comment">// Remove the least violated cut</span></div>
<div class="line"><span class="lineno">  649</span>                                    cutQueue.push(vCut);</div>
<div class="line"><span class="lineno">  650</span>                                }</div>
<div class="line"><span class="lineno">  651</span><span class="comment">// CachedCut newCachedCut{cut, alpha};</span></div>
<div class="line"><span class="lineno">  652</span><span class="comment">// cutCache.push_back(newCachedCut);</span></div>
<div class="line"><span class="lineno">  653</span>#ifdef NSYNC</div>
<div class="line"><span class="lineno">  654</span>                                nsync::nsync_mu_unlock(&amp;cuts_mutex);</div>
<div class="line"><span class="lineno">  655</span>#endif</div>
<div class="line"><span class="lineno">  656</span>                            }</div>
<div class="line"><span class="lineno">  657</span>                            <span class="comment">// increment the cuts_count</span></div>
<div class="line"><span class="lineno">  658</span>                            cuts_count.fetch_add(1);</div>
<div class="line"><span class="lineno">  659</span> </div>
<div class="line"><span class="lineno">  660</span>                            if (cuts_count.load() &gt; max_generated_cuts) { return; }</div>
<div class="line"><span class="lineno">  661</span>                        }</div>
<div class="line"><span class="lineno">  662</span>                    }</div>
<div class="line"><span class="lineno">  663</span>                }</div>
<div class="line"><span class="lineno">  664</span>            }</div>
<div class="line"><span class="lineno">  665</span>        });</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span>    <span class="keyword">auto</span> work = stdexec::starts_on(sched, bulk_sender);</div>
<div class="line"><span class="lineno">  668</span>    stdexec::sync_wait(std::move(work));</div>
<div class="line"><span class="lineno">  669</span> </div>
<div class="line"><span class="lineno">  670</span>    <span class="keywordflow">while</span> (!cutQueue.empty()) {</div>
<div class="line"><span class="lineno">  671</span>        <span class="keyword">auto</span> topCut = cutQueue.top();</div>
<div class="line"><span class="lineno">  672</span>        <a class="code hl_variable" href="#a582069540ed19e7a5ec234bd7a0fa4d3">cutStorage</a>.<a class="code hl_function" href="classCutStorage.html#aa59db0e52f4d6d9007f46fdc47324e6c">addCut</a>(topCut.second);</div>
<div class="line"><span class="lineno">  673</span>        cutQueue.pop();</div>
<div class="line"><span class="lineno">  674</span>    }</div>
<div class="line"><span class="lineno">  675</span>}</div>
<div class="ttc" id="aDefinitions_8h_html_a64e2fe830f0e02b5ac2beb9c0ff3425fa11644190d0aa82e0784bd5b8a9530d03"><div class="ttname"><a href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa11644190d0aa82e0784bd5b8a9530d03">CutType::FourRow</a></div><div class="ttdeci">@ FourRow</div></div>
<div class="ttc" id="aDefinitions_8h_html_a64e2fe830f0e02b5ac2beb9c0ff3425fa4c5d066c0fda7499381bc409dd736b70"><div class="ttname"><a href="Definitions_8h.html#a64e2fe830f0e02b5ac2beb9c0ff3425fa4c5d066c0fda7499381bc409dd736b70">CutType::FiveRow</a></div><div class="ttdeci">@ FiveRow</div></div>
<div class="ttc" id="aSRC_8h_html_a0ec7e413b362fcfa33e475b88198ff9b"><div class="ttname"><a href="SRC_8h.html#a0ec7e413b362fcfa33e475b88198ff9b">getPermutationsForSize5</a></div><div class="ttdeci">std::vector&lt; SRCPermutation &gt; getPermutationsForSize5()</div><div class="ttdoc">Generates all unique permutations for a predefined set of vectors of size 5.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00174">SRC.h:174</a></div></div>
<div class="ttc" id="aSRC_8h_html_abd5d9a806975ce95efb3b8ce3e6fe2e5"><div class="ttname"><a href="SRC_8h.html#abd5d9a806975ce95efb3b8ce3e6fe2e5">getPermutationsForSize4</a></div><div class="ttdeci">std::vector&lt; SRCPermutation &gt; getPermutationsForSize4()</div><div class="ttdoc">Generates all unique permutations of a fixed-size vector.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00216">SRC.h:216</a></div></div>
<div class="ttc" id="aSRC_8h_html_ac1e86f60f149c469a628f58f3e595221"><div class="ttname"><a href="SRC_8h.html#ac1e86f60f149c469a628f58f3e595221">combinations</a></div><div class="ttdeci">void combinations(const std::vector&lt; T &gt; &amp;elements, int k, int max_combinations, std::vector&lt; std::vector&lt; T &gt; &gt; &amp;result)</div><div class="ttdoc">Generates all combinations of a given size from a set of elements.</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00243">SRC.h:243</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a079bd845ca33bdfc18be9e392626acc0"><div class="ttname"><a href="#a079bd845ca33bdfc18be9e392626acc0">LimitedMemoryRank1Cuts::CutPriorityQueue</a></div><div class="ttdeci">std::priority_queue&lt; ViolatedCut, std::vector&lt; ViolatedCut &gt;, CompareCuts &gt; CutPriorityQueue</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00154">SRC.h:154</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_a9ee64e3c2c61461ce2755bfa73f7697b"><div class="ttname"><a href="#a9ee64e3c2c61461ce2755bfa73f7697b">LimitedMemoryRank1Cuts::cutCache4</a></div><div class="ttdeci">std::vector&lt; CachedCut &gt; cutCache4</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00089">SRC.h:89</a></div></div>
<div class="ttc" id="aclassLimitedMemoryRank1Cuts_html_ade7540a903f5c7b58271db330f0013d6"><div class="ttname"><a href="#ade7540a903f5c7b58271db330f0013d6">LimitedMemoryRank1Cuts::cutCache5</a></div><div class="ttdeci">std::vector&lt; CachedCut &gt; cutCache5</div><div class="ttdef"><b>Definition</b> <a href="SRC_8h_source.html#l00090">SRC.h:90</a></div></div>
<div class="ttc" id="aclassXoroshiro128Plus_html"><div class="ttname"><a href="classXoroshiro128Plus.html">Xoroshiro128Plus</a></div><div class="ttdef"><b>Definition</b> <a href="RNG_8h_source.html#l00008">RNG.h:8</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLimitedMemoryRank1Cuts_a7b3eba87af98185081086c5f5b34c5ce_cgraph.png" border="0" usemap="#aclassLimitedMemoryRank1Cuts_a7b3eba87af98185081086c5f5b34c5ce_cgraph" alt=""/></div>
<map name="aclassLimitedMemoryRank1Cuts_a7b3eba87af98185081086c5f5b34c5ce_cgraph" id="aclassLimitedMemoryRank1Cuts_a7b3eba87af98185081086c5f5b34c5ce_cgraph">
<area shape="rect" title="Implements the 45 Heuristic for generating limited memory rank&#45;1 cuts." alt="" coords="5,47,180,88"/>
<area shape="rect" href="SRC_8h.html#ac1e86f60f149c469a628f58f3e595221" title="Generates all combinations of a given size from a set of elements." alt="" coords="262,5,360,31"/>
<area shape="poly" title=" " alt="" coords="179,45,246,30,247,35,180,50"/>
<area shape="rect" href="SRC_8h.html#abd5d9a806975ce95efb3b8ce3e6fe2e5" title="Generates all unique permutations of a fixed&#45;size vector." alt="" coords="228,55,395,80"/>
<area shape="poly" title=" " alt="" coords="180,65,212,65,212,70,180,70"/>
<area shape="rect" href="SRC_8h.html#a0ec7e413b362fcfa33e475b88198ff9b" title="Generates all unique permutations for a predefined set of vectors of size 5." alt="" coords="228,104,395,130"/>
<area shape="poly" title=" " alt="" coords="180,85,237,97,236,103,179,90"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaad518dd2434c218df7e9283238a6577" name="aaad518dd2434c218df7e9283238a6577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad518dd2434c218df7e9283238a6577">&#9670;&#160;</a></span>allPaths</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structPath.html">Path</a>&gt; LimitedMemoryRank1Cuts::allPaths</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00102">102</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="a9ee64e3c2c61461ce2755bfa73f7697b" name="a9ee64e3c2c61461ce2755bfa73f7697b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee64e3c2c61461ce2755bfa73f7697b">&#9670;&#160;</a></span>cutCache4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structCachedCut.html">CachedCut</a>&gt; LimitedMemoryRank1Cuts::cutCache4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00089">89</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="ade7540a903f5c7b58271db330f0013d6" name="ade7540a903f5c7b58271db330f0013d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7540a903f5c7b58271db330f0013d6">&#9670;&#160;</a></span>cutCache5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structCachedCut.html">CachedCut</a>&gt; LimitedMemoryRank1Cuts::cutCache5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00090">90</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="a582069540ed19e7a5ec234bd7a0fa4d3" name="a582069540ed19e7a5ec234bd7a0fa4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582069540ed19e7a5ec234bd7a0fa4d3">&#9670;&#160;</a></span>cutStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCutStorage.html">CutStorage</a> LimitedMemoryRank1Cuts::cutStorage = <a class="el" href="classCutStorage.html">CutStorage</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00099">99</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="a5b3eac915da287987fb15c33d9cdab99" name="a5b3eac915da287987fb15c33d9cdab99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3eac915da287987fb15c33d9cdab99">&#9670;&#160;</a></span>labels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; LimitedMemoryRank1Cuts::labels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00104">104</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="ac5bcaab96c5a959c0f9ac7a7cea50ff8" name="ac5bcaab96c5a959c0f9ac7a7cea50ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bcaab96c5a959c0f9ac7a7cea50ff8">&#9670;&#160;</a></span>labels_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LimitedMemoryRank1Cuts::labels_counter = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00105">105</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="a2ad457505a281134f1d458e81305ccac" name="a2ad457505a281134f1d458e81305ccac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad457505a281134f1d458e81305ccac">&#9670;&#160;</a></span>rp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a> LimitedMemoryRank1Cuts::rp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00092">92</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<a id="afd9fbfe139aabbb019ed099c0b485f5c" name="afd9fbfe139aabbb019ed099c0b485f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9fbfe139aabbb019ed099c0b485f5c">&#9670;&#160;</a></span>the45selectedNodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; LimitedMemoryRank1Cuts::the45selectedNodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SRC_8h_source.html#l00139">139</a> of file <a class="el" href="SRC_8h_source.html">SRC.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SRC_8h_source.html">SRC.h</a></li>
<li><a class="el" href="SRC_8cpp_source.html">SRC.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classLimitedMemoryRank1Cuts.html">LimitedMemoryRank1Cuts</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
