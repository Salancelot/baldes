<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BALDES: IPSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BALDES
   </div>
   <div id="projectbrief">Bucket Graph Labeling Algorithm for Vehicle Routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classIPSolver.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classIPSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IPSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for solving linear programming problems using an interior point method.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for IPSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver__coll__graph.png" border="0" usemap="#aIPSolver_coll__map" alt="Collaboration graph"/></div>
<map name="aIPSolver_coll__map" id="aIPSolver_coll__map">
<area shape="rect" title="A class for solving linear programming problems using an interior point method." alt="" coords="65,94,136,120"/>
<area shape="rect" href="structResiduals.html" title="A structure to hold various residual vectors and their norms." alt="" coords="5,5,84,31"/>
<area shape="poly" title=" " alt="" coords="63,43,95,92,91,95,58,46"/>
<area shape="rect" href="classSparseSolver.html" title="A class for solving sparse linear systems using various solver types." alt="" coords="108,5,208,31"/>
<area shape="poly" title=" " alt="" coords="144,45,111,95,106,92,139,42"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a61f035c65c660c2f0fcddc687388fb0d" id="r_a61f035c65c660c2f0fcddc687388fb0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f035c65c660c2f0fcddc687388fb0d">getDuals</a> () const</td></tr>
<tr class="separator:a61f035c65c660c2f0fcddc687388fb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b4972a25d69cc80c2a5f4676c1aa93" id="r_a87b4972a25d69cc80c2a5f4676c1aa93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b4972a25d69cc80c2a5f4676c1aa93">getPrimals</a> () const</td></tr>
<tr class="separator:a87b4972a25d69cc80c2a5f4676c1aa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6e8605bf4d41ddd7bf4f8f4384c0a1" id="r_aac6e8605bf4d41ddd7bf4f8f4384c0a1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac6e8605bf4d41ddd7bf4f8f4384c0a1">getObjective</a> () const</td></tr>
<tr class="separator:aac6e8605bf4d41ddd7bf4f8f4384c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365696b5a6356e7f9bc2d4b199fbc9f7" id="r_a365696b5a6356e7f9bc2d4b199fbc9f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a365696b5a6356e7f9bc2d4b199fbc9f7">IPSolver</a> ()</td></tr>
<tr class="separator:a365696b5a6356e7f9bc2d4b199fbc9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ab576c321bd6a0506d9c5bf8362f1a" id="r_ad6ab576c321bd6a0506d9c5bf8362f1a"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6ab576c321bd6a0506d9c5bf8362f1a">convertToSparseDiagonal</a> (const Eigen::VectorXd &amp;vec)</td></tr>
<tr class="memdesc:ad6ab576c321bd6a0506d9c5bf8362f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dense vector to a sparse diagonal matrix.  <br /></td></tr>
<tr class="separator:ad6ab576c321bd6a0506d9c5bf8362f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2651221065511beedd53613296aaddcb" id="r_a2651221065511beedd53613296aaddcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2651221065511beedd53613296aaddcb">convert_to_standard_form</a> (const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, const Eigen::VectorXd &amp;sense, Eigen::SparseMatrix&lt; double &gt; &amp;As, Eigen::VectorXd &amp;bs, Eigen::VectorXd &amp;cs)</td></tr>
<tr class="memdesc:a2651221065511beedd53613296aaddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given linear programming problem to its standard form.  <br /></td></tr>
<tr class="separator:a2651221065511beedd53613296aaddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcb29f3a4d1b424e4daa6921ba2b8e1" id="r_a2dcb29f3a4d1b424e4daa6921ba2b8e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dcb29f3a4d1b424e4daa6921ba2b8e1">update_residuals</a> (<a class="el" href="structResiduals.html">Residuals</a> &amp;<a class="el" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>, const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;lambda, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;w, const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;vbv, const Eigen::VectorXi &amp;vbi, double <a class="el" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, double <a class="el" href="#a957045b153c2587ced811544b5772410">kappa</a>)</td></tr>
<tr class="memdesc:a2dcb29f3a4d1b424e4daa6921ba2b8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the residuals for the interior point method solver.  <br /></td></tr>
<tr class="separator:a2dcb29f3a4d1b424e4daa6921ba2b8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c0e0acdfb28b73b2387a610bf8fbd6" id="r_a55c0e0acdfb28b73b2387a610bf8fbd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55c0e0acdfb28b73b2387a610bf8fbd6">solve_augmented_system</a> (Eigen::VectorXd &amp;dx, Eigen::VectorXd &amp;dy, <a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d)</td></tr>
<tr class="memdesc:a55c0e0acdfb28b73b2387a610bf8fbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the augmented system for the given right-hand side vectors.  <br /></td></tr>
<tr class="separator:a55c0e0acdfb28b73b2387a610bf8fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d79c906c9f170d975b9404e793a14e" id="r_a10d79c906c9f170d975b9404e793a14e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10d79c906c9f170d975b9404e793a14e">solve_augsys</a> (Eigen::VectorXd &amp;delta_x, Eigen::VectorXd &amp;delta_y, Eigen::VectorXd &amp;delta_z, <a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d, const Eigen::VectorXd &amp;xi_u)</td></tr>
<tr class="separator:a10d79c906c9f170d975b9404e793a14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac225cc4dcfe81ae25d3d59bdcb0b029f" id="r_ac225cc4dcfe81ae25d3d59bdcb0b029f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a> (Eigen::VectorXd &amp;Delta_x, Eigen::VectorXd &amp;Delta_lambda, Eigen::VectorXd &amp;Delta_w, Eigen::VectorXd &amp;Delta_s, Eigen::VectorXd &amp;Delta_v, double &amp;Delta_tau, double &amp;Delta_kappa, <a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXd &amp;delta_x, const Eigen::VectorXd &amp;delta_y, const Eigen::VectorXd &amp;delta_w, double delta_0, const Eigen::VectorXd &amp;iter_x, const Eigen::VectorXd &amp;iter_lambda, const Eigen::VectorXd &amp;iter_w, const Eigen::VectorXd &amp;iter_s, const Eigen::VectorXd &amp;iter_v, double iter_tau, double iter_kappa, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_u, const Eigen::VectorXd &amp;xi_d, double xi_g, const Eigen::VectorXd &amp;xi_xs, const Eigen::VectorXd &amp;xi_vw, double xi_tau_kappa)</td></tr>
<tr class="memdesc:ac225cc4dcfe81ae25d3d59bdcb0b029f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Newton system for the interior point method.  <br /></td></tr>
<tr class="separator:ac225cc4dcfe81ae25d3d59bdcb0b029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3037642e4e2090f62e90d9df5eee9f" id="r_add3037642e4e2090f62e90d9df5eee9f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a> (const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv)</td></tr>
<tr class="memdesc:add3037642e4e2090f62e90d9df5eee9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum step size (alpha) for a single direction vector.  <br /></td></tr>
<tr class="separator:add3037642e4e2090f62e90d9df5eee9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c38201e3fc179e9265a82e67510679" id="r_a16c38201e3fc179e9265a82e67510679"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a> (const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;dx, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;ds, const Eigen::VectorXd &amp;w, const Eigen::VectorXd &amp;dw, double <a class="el" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, double dtau, double <a class="el" href="#a957045b153c2587ced811544b5772410">kappa</a>, double dkappa)</td></tr>
<tr class="memdesc:a16c38201e3fc179e9265a82e67510679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum step size (alpha) that can be taken along the direction of the search vectors.  <br /></td></tr>
<tr class="separator:a16c38201e3fc179e9265a82e67510679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc02635739446925971f247ee90227ad" id="r_acc02635739446925971f247ee90227ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc02635739446925971f247ee90227ad">run_optimization</a> (<a class="el" href="structModelData.html">ModelData</a> &amp;model, const double <a class="el" href="#ac1a5e7d41b0f72ce616f99b03d4785a5">tol</a>)</td></tr>
<tr class="memdesc:acc02635739446925971f247ee90227ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the optimization process on the given model data.  <br /></td></tr>
<tr class="separator:acc02635739446925971f247ee90227ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6983d42c0a0af7344a9c7f9b79cdfe" id="r_a2f6983d42c0a0af7344a9c7f9b79cdfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structOptimizationData.html">OptimizationData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">convertToOptimizationData</a> (const <a class="el" href="structModelData.html">ModelData</a> &amp;modelData)</td></tr>
<tr class="separator:a2f6983d42c0a0af7344a9c7f9b79cdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab307fb2afd387146ea711f123caf12d6" id="r_ab307fb2afd387146ea711f123caf12d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab307fb2afd387146ea711f123caf12d6">update_linear_solver</a> (<a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;theta, const Eigen::VectorXd &amp;regP, const Eigen::VectorXd &amp;regD)</td></tr>
<tr class="separator:ab307fb2afd387146ea711f123caf12d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac549fa9ef9fd8c98dc9262550a81f4d" id="r_aac549fa9ef9fd8c98dc9262550a81f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac549fa9ef9fd8c98dc9262550a81f4d">start_linear_solver</a> (<a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::SparseMatrix&lt; double &gt; A)</td></tr>
<tr class="separator:aac549fa9ef9fd8c98dc9262550a81f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af3536735b8f4efc21e11a83b8062f5f2" id="r_af3536735b8f4efc21e11a83b8062f5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structResiduals.html">Residuals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a></td></tr>
<tr class="separator:af3536735b8f4efc21e11a83b8062f5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55da355d90e490435337a5427b3c0c" id="r_a5c55da355d90e490435337a5427b3c0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseSolver.html">SparseSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a></td></tr>
<tr class="separator:a5c55da355d90e490435337a5427b3c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54987d081f0eebc91d6a0247c471d92a" id="r_a54987d081f0eebc91d6a0247c471d92a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a></td></tr>
<tr class="separator:a54987d081f0eebc91d6a0247c471d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957045b153c2587ced811544b5772410" id="r_a957045b153c2587ced811544b5772410"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a957045b153c2587ced811544b5772410">kappa</a></td></tr>
<tr class="separator:a957045b153c2587ced811544b5772410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a5e7d41b0f72ce616f99b03d4785a5" id="r_ac1a5e7d41b0f72ce616f99b03d4785a5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1a5e7d41b0f72ce616f99b03d4785a5">tol</a></td></tr>
<tr class="separator:ac1a5e7d41b0f72ce616f99b03d4785a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c2594ea4f46d9be99f18a27b34a7d8" id="r_ad0c2594ea4f46d9be99f18a27b34a7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c2594ea4f46d9be99f18a27b34a7d8">max_iter</a></td></tr>
<tr class="separator:ad0c2594ea4f46d9be99f18a27b34a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981ecfeb17af8eebcb536c8ec5075e28" id="r_a981ecfeb17af8eebcb536c8ec5075e28"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="separator:a981ecfeb17af8eebcb536c8ec5075e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120a3a2e1d4aa282ef28da6ca378d7bc" id="r_a120a3a2e1d4aa282ef28da6ca378d7bc"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a120a3a2e1d4aa282ef28da6ca378d7bc">x_old</a></td></tr>
<tr class="separator:a120a3a2e1d4aa282ef28da6ca378d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade64d46c893afea62c9c761d8c93991d" id="r_ade64d46c893afea62c9c761d8c93991d"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade64d46c893afea62c9c761d8c93991d">lambda_old</a></td></tr>
<tr class="separator:ade64d46c893afea62c9c761d8c93991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a3f9beb44ee2ba28b0d5cc8ea6edfb" id="r_ac9a3f9beb44ee2ba28b0d5cc8ea6edfb"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9a3f9beb44ee2ba28b0d5cc8ea6edfb">s_old</a></td></tr>
<tr class="separator:ac9a3f9beb44ee2ba28b0d5cc8ea6edfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34388a63283d1d26ccd9b77f879c16b" id="r_ab34388a63283d1d26ccd9b77f879c16b"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab34388a63283d1d26ccd9b77f879c16b">v_old</a></td></tr>
<tr class="separator:ab34388a63283d1d26ccd9b77f879c16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f8ae7257d8a77f3caa63b3de21588c" id="r_a31f8ae7257d8a77f3caa63b3de21588c"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f8ae7257d8a77f3caa63b3de21588c">w_old</a></td></tr>
<tr class="separator:a31f8ae7257d8a77f3caa63b3de21588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60db34cbbec5a679411c8ec9d25f2dcd" id="r_a60db34cbbec5a679411c8ec9d25f2dcd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60db34cbbec5a679411c8ec9d25f2dcd">tau_old</a></td></tr>
<tr class="separator:a60db34cbbec5a679411c8ec9d25f2dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64d7bec3101a6366409c58206d976d" id="r_afc64d7bec3101a6366409c58206d976d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc64d7bec3101a6366409c58206d976d">kappa_old</a></td></tr>
<tr class="separator:afc64d7bec3101a6366409c58206d976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d4563c64b404dc1c6a973f9b899508" id="r_af1d4563c64b404dc1c6a973f9b899508"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1d4563c64b404dc1c6a973f9b899508">n_slacks_old</a> = 0</td></tr>
<tr class="separator:af1d4563c64b404dc1c6a973f9b899508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6e2a7694ec8befa9470e1aa4acf438" id="r_a4c6e2a7694ec8befa9470e1aa4acf438"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c6e2a7694ec8befa9470e1aa4acf438">n_slacks</a> = 0</td></tr>
<tr class="separator:a4c6e2a7694ec8befa9470e1aa4acf438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9b941d7216d239af63eede001ab647" id="r_a6b9b941d7216d239af63eede001ab647"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b9b941d7216d239af63eede001ab647">warm_start</a> = false</td></tr>
<tr class="separator:a6b9b941d7216d239af63eede001ab647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b689456be5e57ddcadae9254dc35c4a" id="r_a8b689456be5e57ddcadae9254dc35c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b689456be5e57ddcadae9254dc35c4a">dual_vals</a></td></tr>
<tr class="separator:a8b689456be5e57ddcadae9254dc35c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a138d4376f21d730e110d0547af83b" id="r_a77a138d4376f21d730e110d0547af83b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a138d4376f21d730e110d0547af83b">primal_vals</a></td></tr>
<tr class="separator:a77a138d4376f21d730e110d0547af83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46689efc5c499d0e9b53b661e0a5405e" id="r_a46689efc5c499d0e9b53b661e0a5405e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46689efc5c499d0e9b53b661e0a5405e">objVal</a></td></tr>
<tr class="separator:a46689efc5c499d0e9b53b661e0a5405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for solving linear programming problems using an interior point method. </p>
<p>This class provides methods to convert linear programming problems to standard form, update residuals, solve augmented systems, and run the optimization process. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00251">251</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a365696b5a6356e7f9bc2d4b199fbc9f7" name="a365696b5a6356e7f9bc2d4b199fbc9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365696b5a6356e7f9bc2d4b199fbc9f7">&#9670;&#160;</a></span>IPSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IPSolver::IPSolver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00281">281</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  281</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2651221065511beedd53613296aaddcb" name="a2651221065511beedd53613296aaddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2651221065511beedd53613296aaddcb">&#9670;&#160;</a></span>convert_to_standard_form()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::convert_to_standard_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>sense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>As</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>bs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>cs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given linear programming problem to its standard form. </p>
<p>This function transforms the input linear programming problem defined by the matrices and vectors A, b, c, lb, ub, and sense into its standard form. The standard form is characterized by having all variables non-negative and all constraints as equalities. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00037">37</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   40</span>                                                                              {</div>
<div class="line"><span class="lineno">   41</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"><span class="lineno">   42</span>    <span class="keyword">const</span> <span class="keywordtype">int</span>    n     = A.rows();</div>
<div class="line"><span class="lineno">   43</span>    <span class="keyword">const</span> <span class="keywordtype">int</span>    m     = A.cols();</div>
<div class="line"><span class="lineno">   44</span> </div>
<div class="line"><span class="lineno">   45</span>    <span class="keywordflow">if</span> (b.size() != n || c.size() != m) {</div>
<div class="line"><span class="lineno">   46</span>        fmt::print(<span class="stringliteral">&quot;b.size(): {}, n: {}, c.size(): {}, m: {}\n&quot;</span>, b.size(), n, c.size(), m);</div>
<div class="line"><span class="lineno">   47</span>        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Size of b or c does not match the matrix A dimensions.&quot;</span>);</div>
<div class="line"><span class="lineno">   48</span>    }</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span>    Eigen::VectorXd lo = lb;</div>
<div class="line"><span class="lineno">   51</span>    Eigen::VectorXd hi = ub;</div>
<div class="line"><span class="lineno">   52</span> </div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordtype">int</span> n_free = 0, n_ubounds = 0, nv = A.cols();</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    <span class="comment">// Precompute bound categories</span></div>
<div class="line"><span class="lineno">   56</span>    std::vector&lt;bool&gt; is_free(lo.size()), is_bounded(lo.size()), is_upper(lo.size()), is_lower(lo.size());</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; lo.size(); ++i) {</div>
<div class="line"><span class="lineno">   58</span>        <span class="keywordflow">if</span> (lo[i] == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; hi[i] == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">   59</span>            is_free[i] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   60</span>            ++n_free;</div>
<div class="line"><span class="lineno">   61</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(lo[i]) &amp;&amp; std::isfinite(hi[i])) {</div>
<div class="line"><span class="lineno">   62</span>            is_bounded[i] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   63</span>            ++n_ubounds;</div>
<div class="line"><span class="lineno">   64</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lo[i] == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; std::isfinite(hi[i])) {</div>
<div class="line"><span class="lineno">   65</span>            is_upper[i] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   66</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(lo[i]) &amp;&amp; hi[i] == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">   67</span>            is_lower[i] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   68</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">   69</span>            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;unexpected bounds&quot;</span>);</div>
<div class="line"><span class="lineno">   70</span>        }</div>
<div class="line"><span class="lineno">   71</span>    }</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    <span class="comment">// Precompute slack variables and reserve memory</span></div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordtype">int</span> num_slacks = n - sense.sum();</div>
<div class="line"><span class="lineno">   75</span>    cs.resize(c.size() + n_free + num_slacks);</div>
<div class="line"><span class="lineno">   76</span>    cs.setZero();</div>
<div class="line"><span class="lineno">   77</span>    cs.head(m) = c;</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>    bs = b; <span class="comment">// Direct assignment</span></div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets;</div>
<div class="line"><span class="lineno">   82</span>    triplets.reserve(A.nonZeros() + num_slacks); <span class="comment">// Reserve space to avoid reallocations</span></div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>    std::vector&lt;int&gt;    ind_ub;</div>
<div class="line"><span class="lineno">   85</span>    std::vector&lt;double&gt; val_ub;</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>    <span class="keyword">auto</span> lb_extended = lb;</div>
<div class="line"><span class="lineno">   88</span>    <span class="keyword">auto</span> ub_extended = ub;</div>
<div class="line"><span class="lineno">   89</span>    lb_extended.conservativeResize(nv + num_slacks + n_free);</div>
<div class="line"><span class="lineno">   90</span>    ub_extended.conservativeResize(nv + num_slacks + n_free);</div>
<div class="line"><span class="lineno">   91</span>    lb_extended.tail(num_slacks + n_free).setZero();</div>
<div class="line"><span class="lineno">   92</span>    ub_extended.tail(num_slacks + n_free).setConstant(1.0);</div>
<div class="line"><span class="lineno">   93</span> </div>
<div class="line"><span class="lineno">   94</span>    <span class="keywordtype">int</span> free = 0, ubi = 0;</div>
<div class="line"><span class="lineno">   95</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; lo.size(); ++j) {</div>
<div class="line"><span class="lineno">   96</span>        <span class="keywordtype">double</span> l = lo[j];</div>
<div class="line"><span class="lineno">   97</span>        <span class="keywordtype">double</span> h = hi[j];</div>
<div class="line"><span class="lineno">   98</span> </div>
<div class="line"><span class="lineno">   99</span>        <span class="keywordflow">for</span> (Eigen::SparseMatrix&lt;double&gt;::InnerIterator it(A, j); it; ++it) {</div>
<div class="line"><span class="lineno">  100</span>            <span class="keywordtype">int</span>    i = it.row();</div>
<div class="line"><span class="lineno">  101</span>            <span class="keywordtype">double</span> v = it.value();</div>
<div class="line"><span class="lineno">  102</span> </div>
<div class="line"><span class="lineno">  103</span>            <span class="keywordflow">if</span> (is_free[j]) {</div>
<div class="line"><span class="lineno">  104</span>                cs[j]         = c[j];</div>
<div class="line"><span class="lineno">  105</span>                cs[nv + free] = -c[j];</div>
<div class="line"><span class="lineno">  106</span>                triplets.emplace_back(i, j, v);</div>
<div class="line"><span class="lineno">  107</span>                triplets.emplace_back(i, nv + free, -v);</div>
<div class="line"><span class="lineno">  108</span>                lb_extended[nv + free] = lb[j];</div>
<div class="line"><span class="lineno">  109</span>                ub_extended[nv + free] = ub[j];</div>
<div class="line"><span class="lineno">  110</span>                ++free;</div>
<div class="line"><span class="lineno">  111</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_bounded[j]) {</div>
<div class="line"><span class="lineno">  112</span>                cs[j] = c[j];</div>
<div class="line"><span class="lineno">  113</span>                bs[i] -= v * l;</div>
<div class="line"><span class="lineno">  114</span>                triplets.emplace_back(i, j, v);</div>
<div class="line"><span class="lineno">  115</span>                ind_ub.push_back(j);</div>
<div class="line"><span class="lineno">  116</span>                val_ub.push_back(h - l);</div>
<div class="line"><span class="lineno">  117</span>                ++ubi;</div>
<div class="line"><span class="lineno">  118</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_upper[j]) {</div>
<div class="line"><span class="lineno">  119</span>                cs[j] = -c[j];</div>
<div class="line"><span class="lineno">  120</span>                bs[i] -= (-v * h);</div>
<div class="line"><span class="lineno">  121</span>                triplets.emplace_back(i, j, -v);</div>
<div class="line"><span class="lineno">  122</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_lower[j]) {</div>
<div class="line"><span class="lineno">  123</span>                cs[j] = c[j];</div>
<div class="line"><span class="lineno">  124</span>                bs[i] -= v * l;</div>
<div class="line"><span class="lineno">  125</span>                triplets.emplace_back(i, j, v);</div>
<div class="line"><span class="lineno">  126</span>            }</div>
<div class="line"><span class="lineno">  127</span>        }</div>
<div class="line"><span class="lineno">  128</span>    }</div>
<div class="line"><span class="lineno">  129</span> </div>
<div class="line"><span class="lineno">  130</span>    <span class="comment">// Add slack variables</span></div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordtype">int</span> slack_counter = 0;</div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sense.size(); ++i) {</div>
<div class="line"><span class="lineno">  133</span>        <span class="keywordflow">if</span> (sense(i) == 0) {</div>
<div class="line"><span class="lineno">  134</span>            <span class="comment">// print nv + n_free + slack_counter</span></div>
<div class="line"><span class="lineno">  135</span>            triplets.emplace_back(i, nv + n_free + slack_counter, 1.0);</div>
<div class="line"><span class="lineno">  136</span>            lb_extended[nv + n_free + slack_counter] = 0.0;</div>
<div class="line"><span class="lineno">  137</span>            ub_extended[nv + n_free + slack_counter] = <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>;</div>
<div class="line"><span class="lineno">  138</span>            ++slack_counter;</div>
<div class="line"><span class="lineno">  139</span>        }</div>
<div class="line"><span class="lineno">  140</span>    }</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>    <span class="comment">// Construct sparse matrix As</span></div>
<div class="line"><span class="lineno">  143</span>    As.resize(bs.size(), cs.size());</div>
<div class="line"><span class="lineno">  144</span>    As.setFromTriplets(triplets.begin(), triplets.end());</div>
<div class="line"><span class="lineno">  145</span>    As.makeCompressed();</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>    <a class="code hl_variable" href="#a4c6e2a7694ec8befa9470e1aa4acf438">n_slacks</a> = num_slacks;</div>
<div class="line"><span class="lineno">  148</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a4c6e2a7694ec8befa9470e1aa4acf438"><div class="ttname"><a href="#a4c6e2a7694ec8befa9470e1aa4acf438">IPSolver::n_slacks</a></div><div class="ttdeci">int n_slacks</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00269">IPSolver.h:269</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a981ecfeb17af8eebcb536c8ec5075e28"><div class="ttname"><a href="#a981ecfeb17af8eebcb536c8ec5075e28">IPSolver::infty</a></div><div class="ttdeci">double infty</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00258">IPSolver.h:258</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f6983d42c0a0af7344a9c7f9b79cdfe" name="a2f6983d42c0a0af7344a9c7f9b79cdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">&#9670;&#160;</a></span>convertToOptimizationData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOptimizationData.html">OptimizationData</a> IPSolver::convertToOptimizationData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structModelData.html">ModelData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>modelData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00767">767</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  767</span>                                                                               {</div>
<div class="line"><span class="lineno">  768</span>    <a class="code hl_struct" href="structOptimizationData.html">OptimizationData</a> optData;</div>
<div class="line"><span class="lineno">  769</span> </div>
<div class="line"><span class="lineno">  770</span>    <span class="comment">// Convert SparseMatrix to Eigen::SparseMatrix using Eigen::Triplet</span></div>
<div class="line"><span class="lineno">  771</span>    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets;</div>
<div class="line"><span class="lineno">  772</span>    <span class="keyword">auto</span>                                sparseMatrix = modelData.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>;</div>
<div class="line"><span class="lineno">  773</span> </div>
<div class="line"><span class="lineno">  774</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#aa2ff8a7b473a5656481967750bd566aa">As</a> = modelData.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>.toEigenSparseMatrix();</div>
<div class="line"><span class="lineno">  775</span> </div>
<div class="line"><span class="lineno">  776</span>    <span class="comment">// Iterate over the CRS format of SparseMatrix to build triplets</span></div>
<div class="line"><span class="lineno">  777</span>    <span class="comment">// for (int i = 0; i &lt; sparseMatrix.outerSize(); ++i) {</span></div>
<div class="line"><span class="lineno">  778</span>    <span class="comment">//    for (Eigen::SparseMatrix&lt;double&gt;::InnerIterator it(sparseMatrix, i); it; ++it) {</span></div>
<div class="line"><span class="lineno">  779</span>    <span class="comment">//        triplets.push_back(Eigen::Triplet&lt;double&gt;(it.row(), it.col(), it.value()));</span></div>
<div class="line"><span class="lineno">  780</span>    <span class="comment">//    }</span></div>
<div class="line"><span class="lineno">  781</span>    <span class="comment">//}</span></div>
<div class="line"><span class="lineno">  782</span>    <span class="comment">// Resize the Eigen sparse matrix</span></div>
<div class="line"><span class="lineno">  783</span>    <span class="comment">// optData.As.resize(sparseMatrix.num_rows, sparseMatrix.num_cols);</span></div>
<div class="line"><span class="lineno">  784</span> </div>
<div class="line"><span class="lineno">  785</span>    <span class="comment">// Set the values from the triplets</span></div>
<div class="line"><span class="lineno">  786</span>    <span class="comment">// optData.As.setFromTriplets(triplets.begin(), triplets.end());</span></div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    <span class="comment">// Make the matrix compressed for efficient operations</span></div>
<div class="line"><span class="lineno">  789</span>    <span class="comment">// optData.As.makeCompressed();</span></div>
<div class="line"><span class="lineno">  790</span> </div>
<div class="line"><span class="lineno">  791</span>    <span class="comment">// Convert b to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  792</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">bs</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#aea9d2f5b3aa72a3af01c62c7cd9d81f2">b</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#aea9d2f5b3aa72a3af01c62c7cd9d81f2">b</a>.size());</div>
<div class="line"><span class="lineno">  793</span> </div>
<div class="line"><span class="lineno">  794</span>    <span class="comment">// Convert c to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  795</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#a5b82c8604e7c30d49e34be2b83f84705">cs</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#a9524df699303a08928c2424e50f0c212">c</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#a9524df699303a08928c2424e50f0c212">c</a>.size());</div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span>    <span class="comment">// Convert lb to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  798</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#aaf56347389a91b3384bd9d65b5b2a7a7">lo</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#a80344318cbffc04660646ec38d3f7180">lb</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#a80344318cbffc04660646ec38d3f7180">lb</a>.size());</div>
<div class="line"><span class="lineno">  799</span> </div>
<div class="line"><span class="lineno">  800</span>    <span class="comment">// Convert ub to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  801</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#aa4cf17b671a5017a0f5d9a9c42dea1c0">hi</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#a3454e039aeac6532f64f87599813d962">ub</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#a3454e039aeac6532f64f87599813d962">ub</a>.size());</div>
<div class="line"><span class="lineno">  802</span> </div>
<div class="line"><span class="lineno">  803</span>    <span class="comment">// Convert sense to Eigen::VectorXd (mapping &#39;&lt;&#39; to 0, &#39;=&#39; to 1, &#39;&gt;&#39; to 0 and flipping the corresponding row)</span></div>
<div class="line"><span class="lineno">  804</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>.resize(modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>.size());</div>
<div class="line"><span class="lineno">  805</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>.size(); ++i) {</div>
<div class="line"><span class="lineno">  806</span>        <span class="keywordflow">if</span> (modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>[i] == <span class="charliteral">&#39;&lt;&#39;</span>) {</div>
<div class="line"><span class="lineno">  807</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>[i] = 0.0;</div>
<div class="line"><span class="lineno">  808</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>[i] == <span class="charliteral">&#39;=&#39;</span>) {</div>
<div class="line"><span class="lineno">  809</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>[i] = 1.0;</div>
<div class="line"><span class="lineno">  810</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>[i] == <span class="charliteral">&#39;&gt;&#39;</span>) {</div>
<div class="line"><span class="lineno">  811</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>[i] = 0.0;</div>
<div class="line"><span class="lineno">  812</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">bs</a>[i]    = -optData.<a class="code hl_variable" href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">bs</a>[i];</div>
<div class="line"><span class="lineno">  813</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#aa2ff8a7b473a5656481967750bd566aa">As</a>.row(i) *= -1; <span class="comment">// Flip the row for &#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">  814</span>        }</div>
<div class="line"><span class="lineno">  815</span>    }</div>
<div class="line"><span class="lineno">  816</span> </div>
<div class="line"><span class="lineno">  817</span>    <span class="keywordflow">return</span> optData;</div>
<div class="line"><span class="lineno">  818</span>}</div>
<div class="ttc" id="astructModelData_html_a245b4a1967df894ba7ef7ed10a2c111a"><div class="ttname"><a href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">ModelData::A_sparse</a></div><div class="ttdeci">SparseMatrix A_sparse</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00149">Definitions.h:149</a></div></div>
<div class="ttc" id="astructModelData_html_a3454e039aeac6532f64f87599813d962"><div class="ttname"><a href="structModelData.html#a3454e039aeac6532f64f87599813d962">ModelData::ub</a></div><div class="ttdeci">std::vector&lt; double &gt; ub</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00154">Definitions.h:154</a></div></div>
<div class="ttc" id="astructModelData_html_a80344318cbffc04660646ec38d3f7180"><div class="ttname"><a href="structModelData.html#a80344318cbffc04660646ec38d3f7180">ModelData::lb</a></div><div class="ttdeci">std::vector&lt; double &gt; lb</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00153">Definitions.h:153</a></div></div>
<div class="ttc" id="astructModelData_html_a9524df699303a08928c2424e50f0c212"><div class="ttname"><a href="structModelData.html#a9524df699303a08928c2424e50f0c212">ModelData::c</a></div><div class="ttdeci">std::vector&lt; double &gt; c</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00152">Definitions.h:152</a></div></div>
<div class="ttc" id="astructModelData_html_ac23a00bb904bdff4445e27b1478f3805"><div class="ttname"><a href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">ModelData::sense</a></div><div class="ttdeci">std::vector&lt; char &gt; sense</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00151">Definitions.h:151</a></div></div>
<div class="ttc" id="astructModelData_html_aea9d2f5b3aa72a3af01c62c7cd9d81f2"><div class="ttname"><a href="structModelData.html#aea9d2f5b3aa72a3af01c62c7cd9d81f2">ModelData::b</a></div><div class="ttdeci">std::vector&lt; double &gt; b</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00150">Definitions.h:150</a></div></div>
<div class="ttc" id="astructOptimizationData_html"><div class="ttname"><a href="structOptimizationData.html">OptimizationData</a></div><div class="ttdoc">A structure to hold data for an optimization problem.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00038">IPSolver.h:38</a></div></div>
<div class="ttc" id="astructOptimizationData_html_a11c0e5839dd840148a8bdde9c92c283d"><div class="ttname"><a href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">OptimizationData::sense</a></div><div class="ttdeci">Eigen::VectorXd sense</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00044">IPSolver.h:44</a></div></div>
<div class="ttc" id="astructOptimizationData_html_a3d49a2b24845bf93e19f3bbcb6c3de41"><div class="ttname"><a href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">OptimizationData::bs</a></div><div class="ttdeci">Eigen::VectorXd bs</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00040">IPSolver.h:40</a></div></div>
<div class="ttc" id="astructOptimizationData_html_a5b82c8604e7c30d49e34be2b83f84705"><div class="ttname"><a href="structOptimizationData.html#a5b82c8604e7c30d49e34be2b83f84705">OptimizationData::cs</a></div><div class="ttdeci">Eigen::VectorXd cs</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00041">IPSolver.h:41</a></div></div>
<div class="ttc" id="astructOptimizationData_html_aa2ff8a7b473a5656481967750bd566aa"><div class="ttname"><a href="structOptimizationData.html#aa2ff8a7b473a5656481967750bd566aa">OptimizationData::As</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; double &gt; As</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00039">IPSolver.h:39</a></div></div>
<div class="ttc" id="astructOptimizationData_html_aa4cf17b671a5017a0f5d9a9c42dea1c0"><div class="ttname"><a href="structOptimizationData.html#aa4cf17b671a5017a0f5d9a9c42dea1c0">OptimizationData::hi</a></div><div class="ttdeci">Eigen::VectorXd hi</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00043">IPSolver.h:43</a></div></div>
<div class="ttc" id="astructOptimizationData_html_aaf56347389a91b3384bd9d65b5b2a7a7"><div class="ttname"><a href="structOptimizationData.html#aaf56347389a91b3384bd9d65b5b2a7a7">OptimizationData::lo</a></div><div class="ttdeci">Eigen::VectorXd lo</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00042">IPSolver.h:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad6ab576c321bd6a0506d9c5bf8362f1a" name="ad6ab576c321bd6a0506d9c5bf8362f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ab576c321bd6a0506d9c5bf8362f1a">&#9670;&#160;</a></span>convertToSparseDiagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt; double &gt; IPSolver::convertToSparseDiagonal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a dense vector to a sparse diagonal matrix. </p>
<p>This function takes a dense vector and converts it into a sparse diagonal matrix. The resulting sparse matrix has non-zero values only on its diagonal, where the values are taken from the input vector. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00022">22</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   22</span>                                                                                    {</div>
<div class="line"><span class="lineno">   23</span>    Eigen::SparseMatrix&lt;double&gt; mat(vec.size(), vec.size());</div>
<div class="line"><span class="lineno">   24</span>    mat = vec.asDiagonal();</div>
<div class="line"><span class="lineno">   25</span>    <span class="keywordflow">return</span> mat;</div>
<div class="line"><span class="lineno">   26</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a61f035c65c660c2f0fcddc687388fb0d" name="a61f035c65c660c2f0fcddc687388fb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f035c65c660c2f0fcddc687388fb0d">&#9670;&#160;</a></span>getDuals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; IPSolver::getDuals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00276">276</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  276</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="#a8b689456be5e57ddcadae9254dc35c4a">dual_vals</a>; }</div>
<div class="ttc" id="aclassIPSolver_html_a8b689456be5e57ddcadae9254dc35c4a"><div class="ttname"><a href="#a8b689456be5e57ddcadae9254dc35c4a">IPSolver::dual_vals</a></div><div class="ttdeci">std::vector&lt; double &gt; dual_vals</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00272">IPSolver.h:272</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aac6e8605bf4d41ddd7bf4f8f4384c0a1" name="aac6e8605bf4d41ddd7bf4f8f4384c0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6e8605bf4d41ddd7bf4f8f4384c0a1">&#9670;&#160;</a></span>getObjective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::getObjective </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00278">278</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  278</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="#a46689efc5c499d0e9b53b661e0a5405e">objVal</a>; }</div>
<div class="ttc" id="aclassIPSolver_html_a46689efc5c499d0e9b53b661e0a5405e"><div class="ttname"><a href="#a46689efc5c499d0e9b53b661e0a5405e">IPSolver::objVal</a></div><div class="ttdeci">double objVal</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00274">IPSolver.h:274</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a87b4972a25d69cc80c2a5f4676c1aa93" name="a87b4972a25d69cc80c2a5f4676c1aa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b4972a25d69cc80c2a5f4676c1aa93">&#9670;&#160;</a></span>getPrimals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; IPSolver::getPrimals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00277">277</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  277</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="#a77a138d4376f21d730e110d0547af83b">primal_vals</a>; }</div>
<div class="ttc" id="aclassIPSolver_html_a77a138d4376f21d730e110d0547af83b"><div class="ttname"><a href="#a77a138d4376f21d730e110d0547af83b">IPSolver::primal_vals</a></div><div class="ttdeci">std::vector&lt; double &gt; primal_vals</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00273">IPSolver.h:273</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a16c38201e3fc179e9265a82e67510679" name="a16c38201e3fc179e9265a82e67510679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c38201e3fc179e9265a82e67510679">&#9670;&#160;</a></span>max_alpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::max_alpha </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dtau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>kappa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dkappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum step size (alpha) that can be taken along the direction of the search vectors. </p>
<p>This function calculates the maximum allowable step size (alpha) that can be taken along the direction of the search vectors (dx, dv, ds, dw) without violating certain constraints. It considers the current values of the variables (x, v, s, w) and their respective search directions. Additionally, it takes into account the step sizes for tau and kappa. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00340">340</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  343</span>                                          {</div>
<div class="line"><span class="lineno">  344</span>    <span class="keywordtype">double</span> alpha_tau   = (dtau &lt; 0) ? (-<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> / dtau) : 1.0;</div>
<div class="line"><span class="lineno">  345</span>    <span class="keywordtype">double</span> alpha_kappa = (dkappa &lt; 0) ? (-<a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> / dkappa) : 1.0;</div>
<div class="line"><span class="lineno">  346</span> </div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordtype">double</span> alpha = std::min({1.0, <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(x, dx), <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(v, dv), <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(s, ds),</div>
<div class="line"><span class="lineno">  348</span>                             <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(w, dw), alpha_tau, alpha_kappa});</div>
<div class="line"><span class="lineno">  349</span> </div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">return</span> alpha;</div>
<div class="line"><span class="lineno">  351</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a54987d081f0eebc91d6a0247c471d92a"><div class="ttname"><a href="#a54987d081f0eebc91d6a0247c471d92a">IPSolver::tau</a></div><div class="ttdeci">double tau</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00256">IPSolver.h:256</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a957045b153c2587ced811544b5772410"><div class="ttname"><a href="#a957045b153c2587ced811544b5772410">IPSolver::kappa</a></div><div class="ttdeci">double kappa</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00256">IPSolver.h:256</a></div></div>
<div class="ttc" id="aclassIPSolver_html_add3037642e4e2090f62e90d9df5eee9f"><div class="ttname"><a href="#add3037642e4e2090f62e90d9df5eee9f">IPSolver::max_alpha_single</a></div><div class="ttdeci">double max_alpha_single(const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv)</div><div class="ttdoc">Computes the maximum step size (alpha) for a single direction vector.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00317">IPSolver.cpp:317</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph.png" border="0" usemap="#aclassIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph" alt=""/></div>
<map name="aclassIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph" id="aclassIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph">
<area shape="rect" title="Computes the maximum step size (alpha) that can be taken along the direction of the search vectors." alt="" coords="5,13,145,38"/>
<area shape="rect" href="classIPSolver.html#add3037642e4e2090f62e90d9df5eee9f" title="Computes the maximum step size (alpha) for a single direction vector." alt="" coords="193,5,332,46"/>
<area shape="poly" title=" " alt="" coords="145,23,177,23,177,28,145,28"/>
</map>
</div>

</div>
</div>
<a id="add3037642e4e2090f62e90d9df5eee9f" name="add3037642e4e2090f62e90d9df5eee9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3037642e4e2090f62e90d9df5eee9f">&#9670;&#160;</a></span>max_alpha_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::max_alpha_single </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum step size (alpha) for a single direction vector. </p>
<p>This function calculates the maximum allowable step size (alpha) such that the updated vector (v + alpha * dv) remains non-negative. It iterates through each element of the input vectors <code>v</code> and <code>dv</code>, and for each negative element in <code>dv</code>, it computes a potential alpha value. The minimum of these potential alpha values is returned as the result. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00317">317</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  317</span>                                                                                 {</div>
<div class="line"><span class="lineno">  318</span> </div>
<div class="line"><span class="lineno">  319</span>    <span class="keywordtype">double</span> alpha = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"><span class="lineno">  320</span>    <span class="comment">// #pragma omp parallel for reduction(min : alpha)</span></div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; v.size(); ++i) {</div>
<div class="line"><span class="lineno">  322</span>        <span class="keywordflow">if</span> (dv(i) &lt; 0) {</div>
<div class="line"><span class="lineno">  323</span>            <span class="keywordtype">double</span> potential_alpha = -v(i) / dv(i);</div>
<div class="line"><span class="lineno">  324</span>            alpha                  = std::min(alpha, potential_alpha);</div>
<div class="line"><span class="lineno">  325</span>        }</div>
<div class="line"><span class="lineno">  326</span>    }</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span>    <span class="keywordflow">return</span> alpha;</div>
<div class="line"><span class="lineno">  329</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acc02635739446925971f247ee90227ad" name="acc02635739446925971f247ee90227ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc02635739446925971f247ee90227ad">&#9670;&#160;</a></span>run_optimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::run_optimization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structModelData.html">ModelData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the optimization process on the given model data. </p>
<p>This function performs an optimization using an interior point method (IPM) on the provided model data. It converts the model data to a standard form, initializes necessary variables, and iteratively solves the optimization problem until convergence or the maximum number of iterations is reached. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00361">361</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  361</span>                                                                  {</div>
<div class="line"><span class="lineno">  362</span> </div>
<div class="line"><span class="lineno">  363</span>    <span class="comment">// auto componentes = extractOptimizationComponents(model);</span></div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>    <span class="keyword">auto</span> componentes = <a class="code hl_function" href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">convertToOptimizationData</a>(model);</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span>    Eigen::SparseMatrix&lt;double&gt; As    = componentes.As;</div>
<div class="line"><span class="lineno">  368</span>    Eigen::VectorXd             bs    = componentes.bs;</div>
<div class="line"><span class="lineno">  369</span>    Eigen::VectorXd             cs    = componentes.cs;</div>
<div class="line"><span class="lineno">  370</span>    Eigen::VectorXd             lo    = componentes.lo;</div>
<div class="line"><span class="lineno">  371</span>    Eigen::VectorXd             hi    = componentes.hi;</div>
<div class="line"><span class="lineno">  372</span>    Eigen::VectorXd             sense = componentes.sense;</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>    <span class="keyword">auto</span> n_vars_origin = As.cols();</div>
<div class="line"><span class="lineno">  375</span> </div>
<div class="line"><span class="lineno">  376</span>    <span class="comment">//  Convert to standard form;</span></div>
<div class="line"><span class="lineno">  377</span>    Eigen::SparseMatrix&lt;double&gt; A;</div>
<div class="line"><span class="lineno">  378</span>    Eigen::VectorXd             b;</div>
<div class="line"><span class="lineno">  379</span>    Eigen::VectorXd             c;</div>
<div class="line"><span class="lineno">  380</span> </div>
<div class="line"><span class="lineno">  381</span>    <span class="keywordtype">int</span> nv_orig = cs.size();</div>
<div class="line"><span class="lineno">  382</span> </div>
<div class="line"><span class="lineno">  383</span>    <a class="code hl_function" href="#a2651221065511beedd53613296aaddcb">convert_to_standard_form</a>(As, bs, cs, lo, hi, sense, A, b, c);</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span>    <span class="comment">// preconditioner(A, b, c, lo, hi, sense);</span></div>
<div class="line"><span class="lineno">  386</span> </div>
<div class="line"><span class="lineno">  387</span>    <span class="keywordtype">int</span> n = A.cols();</div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordtype">int</span> m = A.rows();</div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span>    <span class="comment">// Output the initial results</span></div>
<div class="line"><span class="lineno">  391</span>    <span class="comment">// Tolerance and maximum iterations</span></div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordtype">int</span> <a class="code hl_variable" href="#ad0c2594ea4f46d9be99f18a27b34a7d8">max_iter</a> = 100;</div>
<div class="line"><span class="lineno">  393</span> </div>
<div class="line"><span class="lineno">  394</span>    <span class="comment">// Initialize vectors and scalars</span></div>
<div class="line"><span class="lineno">  395</span>    Eigen::VectorXd x      = Eigen::VectorXd::Ones(n);</div>
<div class="line"><span class="lineno">  396</span>    Eigen::VectorXd lambda = Eigen::VectorXd::Zero(m);</div>
<div class="line"><span class="lineno">  397</span>    Eigen::VectorXd s      = Eigen::VectorXd::Ones(n);</div>
<div class="line"><span class="lineno">  398</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  399</span><span class="comment">    if (x_old.size() &gt; 0 &amp;&amp; warm_start) {</span></div>
<div class="line"><span class="lineno">  400</span><span class="comment">        int nv_old = x_old.size(); // Original number of variables</span></div>
<div class="line"><span class="lineno">  401</span><span class="comment">        int nv_new = x.size();     // New number of variables</span></div>
<div class="line"><span class="lineno">  402</span><span class="comment">        int mv_old = lambda_old.size();</span></div>
<div class="line"><span class="lineno">  403</span><span class="comment">        int mv_new = lambda.size();</span></div>
<div class="line"><span class="lineno">  404</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  405</span><span class="comment">        // Copy old values to new positions in x</span></div>
<div class="line"><span class="lineno">  406</span><span class="comment">        // As free variables and slack variables are added, the original variables move down</span></div>
<div class="line"><span class="lineno">  407</span><span class="comment">        int original_counter          = 0;</span></div>
<div class="line"><span class="lineno">  408</span><span class="comment">        x.head(nv_old - n_slacks_old) = x_old.head(nv_old - n_slacks_old);</span></div>
<div class="line"><span class="lineno">  409</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="comment">        lambda.head(N_SIZE - 1) = lambda_old.head(N_SIZE - 1);</span></div>
<div class="line"><span class="lineno">  411</span><span class="comment">    }</span></div>
<div class="line"><span class="lineno">  412</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  413</span>    <a class="code hl_variable" href="#a6b9b941d7216d239af63eede001ab647">warm_start</a>   = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  414</span>    <a class="code hl_variable" href="#af1d4563c64b404dc1c6a973f9b899508">n_slacks_old</a> = <a class="code hl_variable" href="#a4c6e2a7694ec8befa9470e1aa4acf438">n_slacks</a>;</div>
<div class="line"><span class="lineno">  415</span>    <span class="comment">// initialize ubi and ubv as empty vectors</span></div>
<div class="line"><span class="lineno">  416</span>    Eigen::VectorXi ubi;</div>
<div class="line"><span class="lineno">  417</span>    Eigen::VectorXd ubv;</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span>    <span class="keywordtype">int</span> count = 0; <span class="comment">// Count of non-zero entries</span></div>
<div class="line"><span class="lineno">  420</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; hi.size(); i++) {</div>
<div class="line"><span class="lineno">  421</span>        <span class="keywordflow">if</span> (hi[i] != std::numeric_limits&lt;double&gt;::infinity()) { count++; }</div>
<div class="line"><span class="lineno">  422</span>    }</div>
<div class="line"><span class="lineno">  423</span> </div>
<div class="line"><span class="lineno">  424</span>    Eigen::VectorXi tempUbi(count);</div>
<div class="line"><span class="lineno">  425</span>    Eigen::VectorXd tempUbv(count);</div>
<div class="line"><span class="lineno">  426</span> </div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordtype">double</span> <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"><span class="lineno">  428</span>    count        = 0;</div>
<div class="line"><span class="lineno">  429</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; hi.size(); i++) {</div>
<div class="line"><span class="lineno">  430</span>        <span class="keywordflow">if</span> (hi[i] != <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  431</span>            tempUbi[count] = i;</div>
<div class="line"><span class="lineno">  432</span>            tempUbv[count] = hi[i];</div>
<div class="line"><span class="lineno">  433</span>            count++;</div>
<div class="line"><span class="lineno">  434</span>        }</div>
<div class="line"><span class="lineno">  435</span>    }</div>
<div class="line"><span class="lineno">  436</span>    ubi = tempUbi;</div>
<div class="line"><span class="lineno">  437</span>    ubv = tempUbv;</div>
<div class="line"><span class="lineno">  438</span> </div>
<div class="line"><span class="lineno">  439</span>    Eigen::VectorXd v = Eigen::VectorXd::Ones(ubv.size());</div>
<div class="line"><span class="lineno">  440</span>    Eigen::VectorXd w = Eigen::VectorXd::Ones(ubv.size());</div>
<div class="line"><span class="lineno">  441</span> </div>
<div class="line"><span class="lineno">  442</span>    <span class="comment">// initialize vbi and vbv as empty vectors</span></div>
<div class="line"><span class="lineno">  443</span>    Eigen::VectorXi vbi;</div>
<div class="line"><span class="lineno">  444</span>    Eigen::VectorXd vbv;</div>
<div class="line"><span class="lineno">  445</span> </div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordtype">double</span> <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>   = 1.0;</div>
<div class="line"><span class="lineno">  447</span>    <span class="keywordtype">double</span> <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> = 1.0;</div>
<div class="line"><span class="lineno">  448</span> </div>
<div class="line"><span class="lineno">  449</span>    <span class="comment">// Assuming lp.nv and lp.nc are the dimensions you need</span></div>
<div class="line"><span class="lineno">  450</span>    Eigen::VectorXd regP = Eigen::VectorXd::Ones(n);</div>
<div class="line"><span class="lineno">  451</span>    Eigen::VectorXd regD = Eigen::VectorXd::Ones(m);</div>
<div class="line"><span class="lineno">  452</span>    <span class="keywordtype">double</span>          regG = 1.0;</div>
<div class="line"><span class="lineno">  453</span> </div>
<div class="line"><span class="lineno">  454</span>    <a class="code hl_class" href="classSparseSolver.html">SparseSolver</a> <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>;</div>
<div class="line"><span class="lineno">  455</span>    <a class="code hl_function" href="#aac549fa9ef9fd8c98dc9262550a81f4d">start_linear_solver</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, A);</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    <span class="keywordtype">int</span> nc = A.rows(); <span class="comment">// Assuming ls is the sparse matrix</span></div>
<div class="line"><span class="lineno">  458</span>    <span class="keywordtype">int</span> nv = A.cols();</div>
<div class="line"><span class="lineno">  459</span>    <span class="keywordtype">int</span> nu = ubi.size();</div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span>    Eigen::VectorXd delta_x(nv), delta_y(nc), delta_z(nu);</div>
<div class="line"><span class="lineno">  462</span>    <span class="comment">// Residuals</span></div>
<div class="line"><span class="lineno">  463</span>    <a class="code hl_struct" href="structResiduals.html">Residuals</a> <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>;</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span>    <span class="comment">// Dimensions and constants</span></div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordtype">double</span> r_min   = std::sqrt(std::numeric_limits&lt;double&gt;::epsilon()); <span class="comment">// approx 1e-8</span></div>
<div class="line"><span class="lineno">  467</span>    <span class="keywordtype">int</span>    attempt = 0, ncor = 0;</div>
<div class="line"><span class="lineno">  468</span>    <span class="comment">// Residual related variables</span></div>
<div class="line"><span class="lineno">  469</span>    <span class="keywordtype">double</span> _p, _d, _g, mu;</div>
<div class="line"><span class="lineno">  470</span>    <span class="comment">// Step length and corrections</span></div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordtype">double</span> alpha, alpha_c, alpha_;</div>
<div class="line"><span class="lineno">  472</span>    <span class="comment">// Damping factors</span></div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordtype">double</span> beta, gamma, damping, oneMinusAlpha;</div>
<div class="line"><span class="lineno">  474</span>    <span class="comment">// Cross products and thresholds</span></div>
<div class="line"><span class="lineno">  475</span>    <span class="keywordtype">double</span> mu_l, mu_u, taukappa, t0;</div>
<div class="line"><span class="lineno">  476</span>    <span class="comment">// Theta values</span></div>
<div class="line"><span class="lineno">  477</span>    Eigen::VectorXd theta_vw, theta_xs;</div>
<div class="line"><span class="lineno">  478</span>    <span class="comment">// Xi values</span></div>
<div class="line"><span class="lineno">  479</span>    Eigen::VectorXd xi_p, xi_d, xi_u, xi_xs, xi_vw;</div>
<div class="line"><span class="lineno">  480</span>    <span class="comment">// Delta values</span></div>
<div class="line"><span class="lineno">  481</span>    Eigen::VectorXd Delta_x(x.size()), Delta_lambda(lambda.size()), Delta_w(w.size()), Delta_s(s.size()),</div>
<div class="line"><span class="lineno">  482</span>        Delta_v(v.size());</div>
<div class="line"><span class="lineno">  483</span>    <span class="keywordtype">double</span> Delta_tau, Delta_kappa;</div>
<div class="line"><span class="lineno">  484</span>    <span class="comment">// Corrected Delta values</span></div>
<div class="line"><span class="lineno">  485</span>    Eigen::VectorXd Delta_x_c(x.size()), Delta_lambda_c(lambda.size()), Delta_w_c(w.size()), Delta_s_c(s.size()),</div>
<div class="line"><span class="lineno">  486</span>        Delta_v_c(v.size());</div>
<div class="line"><span class="lineno">  487</span>    <span class="keywordtype">double</span> Delta_tau_c, Delta_kappa_c;</div>
<div class="line"><span class="lineno">  488</span>    <span class="comment">// Temporary values for corrections</span></div>
<div class="line"><span class="lineno">  489</span>    Eigen::VectorXd xs, vw, t_xs, t_vw;</div>
<div class="line"><span class="lineno">  490</span>    Eigen::ArrayXd  t_xs_lower, t_xs_upper, t_vw_lower, t_vw_upper;</div>
<div class="line"><span class="lineno">  491</span>    <span class="comment">// Delta calculations</span></div>
<div class="line"><span class="lineno">  492</span>    <span class="keywordtype">double</span> delta_0, bl_dot_lambda, correction;</div>
<div class="line"><span class="lineno">  493</span>    <span class="keywordtype">bool</span>   saved_interior_solution = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; <a class="code hl_variable" href="#ad0c2594ea4f46d9be99f18a27b34a7d8">max_iter</a>; ++k) {</div>
<div class="line"><span class="lineno">  495</span>        <span class="comment">// fmt::print(&quot;Iteration {}\n&quot;, k);</span></div>
<div class="line"><span class="lineno">  496</span>        <span class="comment">//  Zero the necessary variables</span></div>
<div class="line"><span class="lineno">  497</span>        ncor = 0;</div>
<div class="line"><span class="lineno">  498</span>        beta = 0.1;</div>
<div class="line"><span class="lineno">  499</span>        <span class="comment">// Zero out the predictor search direction variables</span></div>
<div class="line"><span class="lineno">  500</span>        delta_x.setZero();</div>
<div class="line"><span class="lineno">  501</span>        delta_y.setZero();</div>
<div class="line"><span class="lineno">  502</span>        delta_z.setZero();</div>
<div class="line"><span class="lineno">  503</span> </div>
<div class="line"><span class="lineno">  504</span>        Delta_x.setZero();</div>
<div class="line"><span class="lineno">  505</span>        Delta_lambda.setZero();</div>
<div class="line"><span class="lineno">  506</span>        Delta_w.setZero();</div>
<div class="line"><span class="lineno">  507</span>        Delta_s.setZero();</div>
<div class="line"><span class="lineno">  508</span>        Delta_v.setZero();</div>
<div class="line"><span class="lineno">  509</span>        Delta_tau   = 0.0;</div>
<div class="line"><span class="lineno">  510</span>        Delta_kappa = 0.0;</div>
<div class="line"><span class="lineno">  511</span> </div>
<div class="line"><span class="lineno">  512</span>        <span class="comment">// Update residuals</span></div>
<div class="line"><span class="lineno">  513</span>        <a class="code hl_function" href="#a2dcb29f3a4d1b424e4daa6921ba2b8e1">update_residuals</a>(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>, x, lambda, s, v, w, A, b, c, ubv, ubi, vbv, vbi, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>);</div>
<div class="line"><span class="lineno">  514</span>        mu = (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> + x.dot(s) + v.dot(w)) / (n + ubi.size() + 1.0);</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span>        <span class="comment">// Calculate _p, _d, and _g in parallel</span></div>
<div class="line"><span class="lineno">  517</span>        <span class="comment">// Calculate primal and dual residual norms using Infinity norm</span></div>
<div class="line"><span class="lineno">  518</span>        <span class="keywordtype">double</span> rp_norm  = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a3cb0e8ee76818efdbb792873e419332c">rp</a>.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  519</span>        <span class="keywordtype">double</span> ru_norm  = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a70254a2a6c47d246447061780a337303">ru</a>.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  520</span>        <span class="keywordtype">double</span> rd_norm  = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#ac370dbd3cdc8027a63a8907fd47356e8">rd</a>.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  521</span>        <span class="keywordtype">double</span> b_norm   = b.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  522</span>        <span class="keywordtype">double</span> ubv_norm = ubv.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  523</span>        <span class="keywordtype">double</span> c_norm   = c.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span>        <span class="comment">// Avoid repeated calculations and improve readability</span></div>
<div class="line"><span class="lineno">  526</span>        _p = std::fmax(rp_norm / (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * (1.0 + b_norm)), ru_norm / (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * (1.0 + ubv_norm)));</div>
<div class="line"><span class="lineno">  527</span>        _d = rd_norm / (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * (1.0 + c_norm));</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>        <span class="comment">// Calculate the dot product once for efficiency</span></div>
<div class="line"><span class="lineno">  530</span>        <span class="keywordtype">double</span> bl_dot_lambda = b.dot(lambda) - ubv.dot(w);</div>
<div class="line"><span class="lineno">  531</span>        _g                   = std::abs(c.dot(x) - bl_dot_lambda) / (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> + std::abs(bl_dot_lambda));</div>
<div class="line"><span class="lineno">  532</span> </div>
<div class="line"><span class="lineno">  533</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  534</span><span class="comment">        if (k % 5 == 0 || (k == max_iter - 1)) {</span></div>
<div class="line"><span class="lineno">  535</span><span class="comment">            // Save intermediate solution every 5 iterations or at the last iteration</span></div>
<div class="line"><span class="lineno">  536</span><span class="comment">            // Save only if the current solution is reasonably &quot;central&quot;</span></div>
<div class="line"><span class="lineno">  537</span><span class="comment">            if (!saved_interior_solution &amp;&amp; (_g &lt;= tol * 2)) {</span></div>
<div class="line"><span class="lineno">  538</span><span class="comment">                x_old                   = x;</span></div>
<div class="line"><span class="lineno">  539</span><span class="comment">                lambda_old              = lambda;</span></div>
<div class="line"><span class="lineno">  540</span><span class="comment">                s_old                   = s;</span></div>
<div class="line"><span class="lineno">  541</span><span class="comment">                v_old                   = v;</span></div>
<div class="line"><span class="lineno">  542</span><span class="comment">                w_old                   = w;</span></div>
<div class="line"><span class="lineno">  543</span><span class="comment">                tau_old                 = tau;</span></div>
<div class="line"><span class="lineno">  544</span><span class="comment">                kappa_old               = kappa;</span></div>
<div class="line"><span class="lineno">  545</span><span class="comment">                saved_interior_solution = true;</span></div>
<div class="line"><span class="lineno">  546</span><span class="comment">                warm_start              = true;</span></div>
<div class="line"><span class="lineno">  547</span><span class="comment">            }</span></div>
<div class="line"><span class="lineno">  548</span><span class="comment">        }</span></div>
<div class="line"><span class="lineno">  549</span><span class="comment">        */</span></div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>        <span class="comment">// Check for optimality and infeasibility</span></div>
<div class="line"><span class="lineno">  552</span>        <span class="keywordflow">if</span> (_p &lt;= 1e-10 &amp;&amp; _d &lt;= 1e-10 &amp;&amp; _g &lt;= <a class="code hl_variable" href="#ac1a5e7d41b0f72ce616f99b03d4785a5">tol</a>) { <span class="keywordflow">break</span>; }</div>
<div class="line"><span class="lineno">  553</span>        <span class="comment">// Scaling factors</span></div>
<div class="line"><span class="lineno">  554</span>        theta_vw = w.cwiseQuotient(v);</div>
<div class="line"><span class="lineno">  555</span>        theta_xs = s.cwiseQuotient(x);</div>
<div class="line"><span class="lineno">  556</span> </div>
<div class="line"><span class="lineno">  557</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi.size(); ++i) { theta_xs[ubi[i]] += theta_vw[i]; }</div>
<div class="line"><span class="lineno">  558</span>        <span class="comment">// Update regularizations</span></div>
<div class="line"><span class="lineno">  559</span>        regP = (regP / 10.0).cwiseMax(r_min);</div>
<div class="line"><span class="lineno">  560</span>        regD = (regD / 10.0).cwiseMax(r_min);</div>
<div class="line"><span class="lineno">  561</span>        regG = std::max(r_min, regG / 10.0);</div>
<div class="line"><span class="lineno">  562</span> </div>
<div class="line"><span class="lineno">  563</span>        <span class="comment">// Factorization with retries</span></div>
<div class="line"><span class="lineno">  564</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> attempt = 0; attempt &lt; 5; ++attempt) {</div>
<div class="line"><span class="lineno">  565</span>            <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  566</span>                <span class="comment">// fmt::print(&quot;Attempt {}\n&quot;, attempt);</span></div>
<div class="line"><span class="lineno">  567</span>                <a class="code hl_function" href="#ab307fb2afd387146ea711f123caf12d6">update_linear_solver</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_xs, regP, regD);</div>
<div class="line"><span class="lineno">  568</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  569</span>            } <span class="keywordflow">catch</span> (std::runtime_error &amp;) {</div>
<div class="line"><span class="lineno">  570</span>                regP *= 100.0;</div>
<div class="line"><span class="lineno">  571</span>                regD *= 100.0;</div>
<div class="line"><span class="lineno">  572</span>                regG *= 100.0;</div>
<div class="line"><span class="lineno">  573</span>            }</div>
<div class="line"><span class="lineno">  574</span>        }</div>
<div class="line"><span class="lineno">  575</span> </div>
<div class="line"><span class="lineno">  576</span>        <span class="comment">// update_linear_solver(ls, theta_xs, regP, regD);</span></div>
<div class="line"><span class="lineno">  577</span> </div>
<div class="line"><span class="lineno">  578</span>        <span class="comment">// Solve the augmented system</span></div>
<div class="line"><span class="lineno">  579</span>        <a class="code hl_function" href="#a10d79c906c9f170d975b9404e793a14e">solve_augsys</a>(delta_x, delta_y, delta_z, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, ubi, b, c, ubv);</div>
<div class="line"><span class="lineno">  580</span>        delta_0 = regG + <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> / <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> - delta_x.dot(c) + delta_y.dot(b) - delta_z.dot(ubv);</div>
<div class="line"><span class="lineno">  581</span>        <span class="comment">// Solve the Newton system</span></div>
<div class="line"><span class="lineno">  582</span>        <a class="code hl_function" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a>(Delta_x, Delta_lambda, Delta_w, Delta_s, Delta_v, Delta_tau, Delta_kappa, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, b,</div>
<div class="line"><span class="lineno">  583</span>                            c, ubi, ubv, delta_x, delta_y, delta_z, delta_0, x, lambda, w, s, v, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a3cb0e8ee76818efdbb792873e419332c">rp</a>,</div>
<div class="line"><span class="lineno">  584</span>                            <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a70254a2a6c47d246447061780a337303">ru</a>, <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#ac370dbd3cdc8027a63a8907fd47356e8">rd</a>, <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#aa99ffc1dacb947d10f9e886c3e9005ab">rg</a>, -x.cwiseProduct(s), -v.cwiseProduct(w), -<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>);</div>
<div class="line"><span class="lineno">  585</span> </div>
<div class="line"><span class="lineno">  586</span>        <span class="comment">// Calculate step length</span></div>
<div class="line"><span class="lineno">  587</span>        alpha = <a class="code hl_function" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a>(x, Delta_x, v, Delta_v, s, Delta_s, w, Delta_w, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, Delta_tau, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, Delta_kappa);</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span>        <span class="comment">// Calculate gamma and damping</span></div>
<div class="line"><span class="lineno">  590</span>        oneMinusAlpha = 1.0 - alpha;</div>
<div class="line"><span class="lineno">  591</span>        gamma         = std::fmax(oneMinusAlpha * oneMinusAlpha * std::fmin(beta, oneMinusAlpha), 0.1);</div>
<div class="line"><span class="lineno">  592</span>        damping       = 1.0 - gamma;</div>
<div class="line"><span class="lineno">  593</span> </div>
<div class="line"><span class="lineno">  594</span>        <a class="code hl_function" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a>(Delta_x, Delta_lambda, Delta_w, Delta_s, Delta_v, Delta_tau, Delta_kappa, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, b,</div>
<div class="line"><span class="lineno">  595</span>                            c, ubi, ubv, delta_x, delta_y, delta_z, delta_0, x, lambda, w, s, v, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>,</div>
<div class="line"><span class="lineno">  596</span>                            damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a3cb0e8ee76818efdbb792873e419332c">rp</a>, damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a70254a2a6c47d246447061780a337303">ru</a>, damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#ac370dbd3cdc8027a63a8907fd47356e8">rd</a>, damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#aa99ffc1dacb947d10f9e886c3e9005ab">rg</a>,</div>
<div class="line"><span class="lineno">  597</span>                            (-x.cwiseProduct(s)).array() + (gamma * mu) - Delta_x.cwiseProduct(Delta_s).array(),</div>
<div class="line"><span class="lineno">  598</span>                            (-v.cwiseProduct(w)).array() + (gamma * mu) - Delta_v.cwiseProduct(Delta_w).array(),</div>
<div class="line"><span class="lineno">  599</span>                            (-<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>) + (gamma * mu) - Delta_tau * Delta_kappa);</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>        alpha = <a class="code hl_function" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a>(x, Delta_x, v, Delta_v, s, Delta_s, w, Delta_w, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, Delta_tau, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, Delta_kappa);</div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>        <span class="comment">// High order corrections like Tulip</span></div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">while</span> ((ncor &lt;= 1) &amp;&amp; (alpha &lt; 0.9995)) {</div>
<div class="line"><span class="lineno">  605</span>            ncor += 1;</div>
<div class="line"><span class="lineno">  606</span>            alpha_ = std::min(1.0, 2.0 * alpha);</div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>            mu_l = beta * mu * gamma;</div>
<div class="line"><span class="lineno">  609</span>            mu_u = gamma * mu / beta;</div>
<div class="line"><span class="lineno">  610</span> </div>
<div class="line"><span class="lineno">  611</span>            <span class="comment">// Perform in-place updates and avoid creating temporaries</span></div>
<div class="line"><span class="lineno">  612</span>            xs = x + alpha_ * Delta_x;</div>
<div class="line"><span class="lineno">  613</span>            xs.array() *= (s.array() + alpha_ * Delta_s.array());</div>
<div class="line"><span class="lineno">  614</span> </div>
<div class="line"><span class="lineno">  615</span>            vw = v + alpha_ * Delta_v;</div>
<div class="line"><span class="lineno">  616</span>            vw.array() *= (w.array() + alpha_ * Delta_w.array());</div>
<div class="line"><span class="lineno">  617</span> </div>
<div class="line"><span class="lineno">  618</span>            <span class="comment">// Use select only once to minimize temporary objects</span></div>
<div class="line"><span class="lineno">  619</span>            t_xs = (xs.array() &lt; mu_l).select(mu_l - xs.array(), (xs.array() &gt; mu_u).select(mu_u - xs.array(), 0));</div>
<div class="line"><span class="lineno">  620</span>            t_vw = (vw.array() &lt; mu_l).select(mu_l - vw.array(), (vw.array() &gt; mu_u).select(mu_u - vw.array(), 0));</div>
<div class="line"><span class="lineno">  621</span> </div>
<div class="line"><span class="lineno">  622</span>            <span class="comment">// Direct calculation for taukappa and t0</span></div>
<div class="line"><span class="lineno">  623</span>            taukappa = (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> + alpha_ * Delta_tau) * (<a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> + alpha_ * Delta_kappa);</div>
<div class="line"><span class="lineno">  624</span>            t0       = std::clamp(taukappa, mu_l, mu_u) - taukappa;</div>
<div class="line"><span class="lineno">  625</span> </div>
<div class="line"><span class="lineno">  626</span>            <span class="comment">// Calculate sum_correction and subtract in-place</span></div>
<div class="line"><span class="lineno">  627</span>            <span class="keywordtype">double</span> sum_correction = (t_xs.sum() + t_vw.sum() + t0) / (nv + nu + 1);</div>
<div class="line"><span class="lineno">  628</span>            t_xs.array() -= sum_correction;</div>
<div class="line"><span class="lineno">  629</span>            t_vw.array() -= sum_correction;</div>
<div class="line"><span class="lineno">  630</span>            t0 -= sum_correction;</div>
<div class="line"><span class="lineno">  631</span> </div>
<div class="line"><span class="lineno">  632</span>            Delta_x_c      = Delta_x;</div>
<div class="line"><span class="lineno">  633</span>            Delta_lambda_c = Delta_lambda;</div>
<div class="line"><span class="lineno">  634</span>            Delta_w_c      = Delta_w;</div>
<div class="line"><span class="lineno">  635</span>            Delta_s_c      = Delta_s;</div>
<div class="line"><span class="lineno">  636</span>            Delta_v_c      = Delta_v;</div>
<div class="line"><span class="lineno">  637</span>            Delta_tau_c    = Delta_tau;</div>
<div class="line"><span class="lineno">  638</span>            Delta_kappa_c  = Delta_kappa;</div>
<div class="line"><span class="lineno">  639</span> </div>
<div class="line"><span class="lineno">  640</span>            <a class="code hl_function" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a>(Delta_x_c, Delta_lambda_c, Delta_w_c, Delta_s_c, Delta_v_c, Delta_tau_c, Delta_kappa_c,</div>
<div class="line"><span class="lineno">  641</span>                                <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, b, c, ubi, ubv, delta_x, delta_y, delta_z, delta_0, x, lambda, w, s, v,</div>
<div class="line"><span class="lineno">  642</span>                                <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, Eigen::VectorXd::Zero(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a3cb0e8ee76818efdbb792873e419332c">rp</a>.size()), Eigen::VectorXd::Zero(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a70254a2a6c47d246447061780a337303">ru</a>.size()),</div>
<div class="line"><span class="lineno">  643</span>                                Eigen::VectorXd::Zero(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#ac370dbd3cdc8027a63a8907fd47356e8">rd</a>.size()), 0, -t_xs, -t_vw, -t0);</div>
<div class="line"><span class="lineno">  644</span> </div>
<div class="line"><span class="lineno">  645</span>            alpha_c = <a class="code hl_function" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a>(x, Delta_x_c, v, Delta_v_c, s, Delta_s_c, w, Delta_w_c, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, Delta_tau_c, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>,</div>
<div class="line"><span class="lineno">  646</span>                                Delta_kappa_c);</div>
<div class="line"><span class="lineno">  647</span> </div>
<div class="line"><span class="lineno">  648</span>            <span class="keywordflow">if</span> (alpha_c &gt; alpha_) {</div>
<div class="line"><span class="lineno">  649</span>                Delta_x      = Delta_x_c;</div>
<div class="line"><span class="lineno">  650</span>                Delta_lambda = Delta_lambda_c;</div>
<div class="line"><span class="lineno">  651</span>                Delta_w      = Delta_w_c;</div>
<div class="line"><span class="lineno">  652</span>                Delta_s      = Delta_s_c;</div>
<div class="line"><span class="lineno">  653</span>                Delta_v      = Delta_v_c;</div>
<div class="line"><span class="lineno">  654</span>                Delta_tau    = Delta_tau_c;</div>
<div class="line"><span class="lineno">  655</span>                Delta_kappa  = Delta_kappa_c;</div>
<div class="line"><span class="lineno">  656</span>                alpha        = alpha_c;</div>
<div class="line"><span class="lineno">  657</span>            }</div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span>            <span class="keywordflow">if</span> (alpha_c &lt; 1.1 * alpha_) { <span class="keywordflow">break</span>; }</div>
<div class="line"><span class="lineno">  660</span>        }</div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span>        alpha *= 0.9995;</div>
<div class="line"><span class="lineno">  663</span> </div>
<div class="line"><span class="lineno">  664</span>        <span class="comment">// Update iterates</span></div>
<div class="line"><span class="lineno">  665</span>        x += alpha * Delta_x;</div>
<div class="line"><span class="lineno">  666</span>        lambda += alpha * Delta_lambda;</div>
<div class="line"><span class="lineno">  667</span>        s += alpha * Delta_s;</div>
<div class="line"><span class="lineno">  668</span>        v += alpha * Delta_v;</div>
<div class="line"><span class="lineno">  669</span>        w += alpha * Delta_w;</div>
<div class="line"><span class="lineno">  670</span>        <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> += alpha * Delta_tau;</div>
<div class="line"><span class="lineno">  671</span>        <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> += alpha * Delta_kappa;</div>
<div class="line"><span class="lineno">  672</span>    }</div>
<div class="line"><span class="lineno">  673</span> </div>
<div class="line"><span class="lineno">  674</span>    <span class="keywordtype">int</span>    free_var = 0;</div>
<div class="line"><span class="lineno">  675</span>    <span class="keywordtype">double</span> inv_tau  = 1.0 / <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>;</div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span>    Eigen::VectorXd original_x(As.cols());</div>
<div class="line"><span class="lineno">  678</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; lo.size(); ++j) {</div>
<div class="line"><span class="lineno">  679</span>        <span class="keywordtype">double</span> l = lo[j];</div>
<div class="line"><span class="lineno">  680</span>        <span class="keywordtype">double</span> h = hi[j];</div>
<div class="line"><span class="lineno">  681</span> </div>
<div class="line"><span class="lineno">  682</span>        <span class="keywordflow">if</span> (l == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; h == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  683</span>            original_x[j] = (x[j + free_var] - x[nv_orig + free_var]) * inv_tau;</div>
<div class="line"><span class="lineno">  684</span>            free_var += 1;</div>
<div class="line"><span class="lineno">  685</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(l) &amp;&amp; std::isfinite(h)) {</div>
<div class="line"><span class="lineno">  686</span>            original_x[j] = l + x[j] * inv_tau;</div>
<div class="line"><span class="lineno">  687</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (l == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; std::isfinite(h)) {</div>
<div class="line"><span class="lineno">  688</span>            original_x[j] = h - x[j] * inv_tau;</div>
<div class="line"><span class="lineno">  689</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(l) &amp;&amp; h == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  690</span>            original_x[j] = l + x[j] * inv_tau;</div>
<div class="line"><span class="lineno">  691</span>        }</div>
<div class="line"><span class="lineno">  692</span>    }</div>
<div class="line"><span class="lineno">  693</span> </div>
<div class="line"><span class="lineno">  694</span>    <span class="keywordtype">double</span> objetivo = cs.dot(original_x);</div>
<div class="line"><span class="lineno">  695</span>    lambda          = lambda * inv_tau;</div>
<div class="line"><span class="lineno">  696</span> </div>
<div class="line"><span class="lineno">  697</span>    <span class="keywordtype">double</span> dual_obj = b.dot(lambda);</div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>    <span class="comment">// convert lambda to std::vector&lt;double&gt;</span></div>
<div class="line"><span class="lineno">  700</span>    std::vector&lt;double&gt; lambda_vec(lambda.data(), lambda.data() + lambda.size());</div>
<div class="line"><span class="lineno">  701</span>    std::vector&lt;double&gt; original_x_vec(original_x.data(), original_x.data() + original_x.size());</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <a class="code hl_variable" href="#a8b689456be5e57ddcadae9254dc35c4a">dual_vals</a>   = lambda_vec;</div>
<div class="line"><span class="lineno">  704</span>    <a class="code hl_variable" href="#a77a138d4376f21d730e110d0547af83b">primal_vals</a> = original_x_vec;</div>
<div class="line"><span class="lineno">  705</span>    <a class="code hl_variable" href="#a46689efc5c499d0e9b53b661e0a5405e">objVal</a>      = objetivo;</div>
<div class="line"><span class="lineno">  706</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a10d79c906c9f170d975b9404e793a14e"><div class="ttname"><a href="#a10d79c906c9f170d975b9404e793a14e">IPSolver::solve_augsys</a></div><div class="ttdeci">void solve_augsys(Eigen::VectorXd &amp;delta_x, Eigen::VectorXd &amp;delta_y, Eigen::VectorXd &amp;delta_z, SparseSolver &amp;ls, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d, const Eigen::VectorXd &amp;xi_u)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00248">IPSolver.cpp:248</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a16c38201e3fc179e9265a82e67510679"><div class="ttname"><a href="#a16c38201e3fc179e9265a82e67510679">IPSolver::max_alpha</a></div><div class="ttdeci">double max_alpha(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;dx, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;ds, const Eigen::VectorXd &amp;w, const Eigen::VectorXd &amp;dw, double tau, double dtau, double kappa, double dkappa)</div><div class="ttdoc">Computes the maximum step size (alpha) that can be taken along the direction of the search vectors.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00340">IPSolver.cpp:340</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a2651221065511beedd53613296aaddcb"><div class="ttname"><a href="#a2651221065511beedd53613296aaddcb">IPSolver::convert_to_standard_form</a></div><div class="ttdeci">void convert_to_standard_form(const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, const Eigen::VectorXd &amp;sense, Eigen::SparseMatrix&lt; double &gt; &amp;As, Eigen::VectorXd &amp;bs, Eigen::VectorXd &amp;cs)</div><div class="ttdoc">Converts the given linear programming problem to its standard form.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00037">IPSolver.cpp:37</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a2dcb29f3a4d1b424e4daa6921ba2b8e1"><div class="ttname"><a href="#a2dcb29f3a4d1b424e4daa6921ba2b8e1">IPSolver::update_residuals</a></div><div class="ttdeci">void update_residuals(Residuals &amp;res, const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;lambda, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;w, const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;vbv, const Eigen::VectorXi &amp;vbi, double tau, double kappa)</div><div class="ttdoc">Updates the residuals for the interior point method solver.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00157">IPSolver.cpp:157</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a2f6983d42c0a0af7344a9c7f9b79cdfe"><div class="ttname"><a href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">IPSolver::convertToOptimizationData</a></div><div class="ttdeci">OptimizationData convertToOptimizationData(const ModelData &amp;modelData)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00767">IPSolver.cpp:767</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a5c55da355d90e490435337a5427b3c0c"><div class="ttname"><a href="#a5c55da355d90e490435337a5427b3c0c">IPSolver::ls</a></div><div class="ttdeci">SparseSolver ls</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00255">IPSolver.h:255</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a6b9b941d7216d239af63eede001ab647"><div class="ttname"><a href="#a6b9b941d7216d239af63eede001ab647">IPSolver::warm_start</a></div><div class="ttdeci">bool warm_start</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00270">IPSolver.h:270</a></div></div>
<div class="ttc" id="aclassIPSolver_html_aac549fa9ef9fd8c98dc9262550a81f4d"><div class="ttname"><a href="#aac549fa9ef9fd8c98dc9262550a81f4d">IPSolver::start_linear_solver</a></div><div class="ttdeci">void start_linear_solver(SparseSolver &amp;ls, const Eigen::SparseMatrix&lt; double &gt; A)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00864">IPSolver.cpp:864</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ab307fb2afd387146ea711f123caf12d6"><div class="ttname"><a href="#ab307fb2afd387146ea711f123caf12d6">IPSolver::update_linear_solver</a></div><div class="ttdeci">void update_linear_solver(SparseSolver &amp;ls, const Eigen::VectorXd &amp;theta, const Eigen::VectorXd &amp;regP, const Eigen::VectorXd &amp;regD)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00820">IPSolver.cpp:820</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ac1a5e7d41b0f72ce616f99b03d4785a5"><div class="ttname"><a href="#ac1a5e7d41b0f72ce616f99b03d4785a5">IPSolver::tol</a></div><div class="ttdeci">double tol</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00256">IPSolver.h:256</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ac225cc4dcfe81ae25d3d59bdcb0b029f"><div class="ttname"><a href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">IPSolver::solve_newton_system</a></div><div class="ttdeci">void solve_newton_system(Eigen::VectorXd &amp;Delta_x, Eigen::VectorXd &amp;Delta_lambda, Eigen::VectorXd &amp;Delta_w, Eigen::VectorXd &amp;Delta_s, Eigen::VectorXd &amp;Delta_v, double &amp;Delta_tau, double &amp;Delta_kappa, SparseSolver &amp;ls, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXd &amp;delta_x, const Eigen::VectorXd &amp;delta_y, const Eigen::VectorXd &amp;delta_w, double delta_0, const Eigen::VectorXd &amp;iter_x, const Eigen::VectorXd &amp;iter_lambda, const Eigen::VectorXd &amp;iter_w, const Eigen::VectorXd &amp;iter_s, const Eigen::VectorXd &amp;iter_v, double iter_tau, double iter_kappa, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_u, const Eigen::VectorXd &amp;xi_d, double xi_g, const Eigen::VectorXd &amp;xi_xs, const Eigen::VectorXd &amp;xi_vw, double xi_tau_kappa)</div><div class="ttdoc">Solves the Newton system for the interior point method.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00277">IPSolver.cpp:277</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ad0c2594ea4f46d9be99f18a27b34a7d8"><div class="ttname"><a href="#ad0c2594ea4f46d9be99f18a27b34a7d8">IPSolver::max_iter</a></div><div class="ttdeci">int max_iter</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00257">IPSolver.h:257</a></div></div>
<div class="ttc" id="aclassIPSolver_html_af1d4563c64b404dc1c6a973f9b899508"><div class="ttname"><a href="#af1d4563c64b404dc1c6a973f9b899508">IPSolver::n_slacks_old</a></div><div class="ttdeci">int n_slacks_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00268">IPSolver.h:268</a></div></div>
<div class="ttc" id="aclassIPSolver_html_af3536735b8f4efc21e11a83b8062f5f2"><div class="ttname"><a href="#af3536735b8f4efc21e11a83b8062f5f2">IPSolver::res</a></div><div class="ttdeci">Residuals res</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00254">IPSolver.h:254</a></div></div>
<div class="ttc" id="aclassSparseSolver_html"><div class="ttname"><a href="classSparseSolver.html">SparseSolver</a></div><div class="ttdoc">A class for solving sparse linear systems using various solver types.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00175">IPSolver.h:175</a></div></div>
<div class="ttc" id="astructResiduals_html"><div class="ttname"><a href="structResiduals.html">Residuals</a></div><div class="ttdoc">A structure to hold various residual vectors and their norms.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00063">IPSolver.h:63</a></div></div>
<div class="ttc" id="astructResiduals_html_a3cb0e8ee76818efdbb792873e419332c"><div class="ttname"><a href="structResiduals.html#a3cb0e8ee76818efdbb792873e419332c">Residuals::rp</a></div><div class="ttdeci">Eigen::VectorXd rp</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00064">IPSolver.h:64</a></div></div>
<div class="ttc" id="astructResiduals_html_a70254a2a6c47d246447061780a337303"><div class="ttname"><a href="structResiduals.html#a70254a2a6c47d246447061780a337303">Residuals::ru</a></div><div class="ttdeci">Eigen::VectorXd ru</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00064">IPSolver.h:64</a></div></div>
<div class="ttc" id="astructResiduals_html_aa99ffc1dacb947d10f9e886c3e9005ab"><div class="ttname"><a href="structResiduals.html#aa99ffc1dacb947d10f9e886c3e9005ab">Residuals::rg</a></div><div class="ttdeci">double rg</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00065">IPSolver.h:65</a></div></div>
<div class="ttc" id="astructResiduals_html_ac370dbd3cdc8027a63a8907fd47356e8"><div class="ttname"><a href="structResiduals.html#ac370dbd3cdc8027a63a8907fd47356e8">Residuals::rd</a></div><div class="ttdeci">Eigen::VectorXd rd</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00064">IPSolver.h:64</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_acc02635739446925971f247ee90227ad_cgraph.png" border="0" usemap="#aclassIPSolver_acc02635739446925971f247ee90227ad_cgraph" alt=""/></div>
<map name="aclassIPSolver_acc02635739446925971f247ee90227ad_cgraph" id="aclassIPSolver_acc02635739446925971f247ee90227ad_cgraph">
<area shape="rect" title="Runs the optimization process on the given model data." alt="" coords="5,200,177,225"/>
<area shape="rect" href="classIPSolver.html#a2651221065511beedd53613296aaddcb" title="Converts the given linear programming problem to its standard form." alt="" coords="273,5,411,46"/>
<area shape="poly" title=" " alt="" coords="98,198,144,130,181,90,223,55,256,40,259,44,226,60,184,94,148,133,102,201"/>
<area shape="rect" href="classIPSolver.html#a2f6983d42c0a0af7344a9c7f9b79cdfe" title=" " alt="" coords="225,70,459,96"/>
<area shape="poly" title=" " alt="" coords="103,197,153,151,186,126,223,105,238,99,240,104,226,109,189,130,156,155,107,201"/>
<area shape="rect" href="classIPSolver.html#a16c38201e3fc179e9265a82e67510679" title="Computes the maximum step size (alpha) that can be taken along the direction of the search vectors." alt="" coords="272,120,412,145"/>
<area shape="poly" title=" " alt="" coords="126,196,224,162,273,147,275,152,225,167,128,201"/>
<area shape="rect" href="classIPSolver.html#a10d79c906c9f170d975b9404e793a14e" title=" " alt="" coords="524,202,680,228"/>
<area shape="poly" title=" " alt="" coords="177,207,225,206,459,206,508,207,508,213,459,211,225,211,177,212"/>
<area shape="rect" href="classIPSolver.html#ac225cc4dcfe81ae25d3d59bdcb0b029f" title="Solves the Newton system for the interior point method." alt="" coords="263,220,420,261"/>
<area shape="poly" title=" " alt="" coords="177,219,248,227,248,233,177,225"/>
<area shape="rect" href="classIPSolver.html#aac549fa9ef9fd8c98dc9262550a81f4d" title=" " alt="" coords="271,285,412,326"/>
<area shape="poly" title=" " alt="" coords="120,223,226,270,257,280,255,286,224,275,118,228"/>
<area shape="rect" href="classIPSolver.html#ab307fb2afd387146ea711f123caf12d6" title=" " alt="" coords="265,351,419,391"/>
<area shape="poly" title=" " alt="" coords="104,224,153,278,188,309,226,335,251,347,249,352,223,340,184,313,149,282,100,227"/>
<area shape="rect" href="classIPSolver.html#a2dcb29f3a4d1b424e4daa6921ba2b8e1" title="Updates the residuals for the interior point method solver." alt="" coords="254,416,430,441"/>
<area shape="poly" title=" " alt="" coords="100,224,116,260,143,309,180,359,202,382,226,401,241,409,239,414,223,405,198,385,176,362,138,311,111,263,95,227"/>
<area shape="rect" href="classIPSolver.html#add3037642e4e2090f62e90d9df5eee9f" title="Computes the maximum step size (alpha) for a single direction vector." alt="" coords="532,112,671,153"/>
<area shape="poly" title=" " alt="" coords="412,130,517,130,517,135,412,135"/>
<area shape="rect" href="classIPSolver.html#a55c0e0acdfb28b73b2387a610bf8fbd6" title="Solves the augmented system for the given right&#45;hand side vectors." alt="" coords="744,195,924,235"/>
<area shape="poly" title=" " alt="" coords="680,212,729,212,729,218,680,218"/>
<area shape="rect" href="classSparseSolver.html#a4337137c45bc2ff28f7e35baa5448417" title=" " alt="" coords="972,202,1108,228"/>
<area shape="poly" title=" " alt="" coords="924,212,956,212,956,218,924,218"/>
<area shape="poly" title=" " alt="" coords="421,230,508,221,508,227,421,235"/>
<area shape="rect" href="classIPSolver.html#ad6ab576c321bd6a0506d9c5bf8362f1a" title="Converts a dense vector to a sparse diagonal matrix." alt="" coords="514,285,690,326"/>
<area shape="poly" title=" " alt="" coords="413,303,498,303,498,308,413,308"/>
<area shape="rect" href="classSparseSolver.html#aaeeba47cb827fd930578cd6d71a35272" title=" " alt="" coords="507,354,696,380"/>
<area shape="poly" title=" " alt="" coords="414,320,530,347,529,353,412,325"/>
<area shape="poly" title=" " alt="" coords="420,367,491,366,491,371,420,372"/>
</map>
</div>

</div>
</div>
<a id="a55c0e0acdfb28b73b2387a610bf8fbd6" name="a55c0e0acdfb28b73b2387a610bf8fbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c0e0acdfb28b73b2387a610bf8fbd6">&#9670;&#160;</a></span>solve_augmented_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::solve_augmented_system </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the augmented system for the given right-hand side vectors. </p>
<p>This function solves the augmented system using either the augmented approach or the regularized approach based on the preprocessor directive <code>AUGMENTED</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>Reference to the vector where the solution for dx will be stored. </td></tr>
    <tr><td class="paramname">dy</td><td>Reference to the vector where the solution for dy will be stored. </td></tr>
    <tr><td class="paramname">ls</td><td>Reference to the sparse solver used to solve the system. </td></tr>
    <tr><td class="paramname">xi_p</td><td>The right-hand side vector corresponding to the primal variables. </td></tr>
    <tr><td class="paramname">xi_d</td><td>The right-hand side vector corresponding to the dual variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00201">201</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  202</span>                                                                                            {</div>
<div class="line"><span class="lineno">  203</span><span class="preprocessor">#ifdef AUGMENTED</span></div>
<div class="line"><span class="lineno">  204</span>    <span class="comment">// Set-up right-hand side</span></div>
<div class="line"><span class="lineno">  205</span>    Eigen::VectorXd xi(xi_d.size() + xi_p.size());</div>
<div class="line"><span class="lineno">  206</span>    xi &lt;&lt; xi_d, xi_p;</div>
<div class="line"><span class="lineno">  207</span> </div>
<div class="line"><span class="lineno">  208</span>    <span class="comment">// Solve augmented system</span></div>
<div class="line"><span class="lineno">  209</span>    Eigen::VectorXd d = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_function" href="classSparseSolver.html#a4337137c45bc2ff28f7e35baa5448417">solve</a>(xi);</div>
<div class="line"><span class="lineno">  210</span> </div>
<div class="line"><span class="lineno">  211</span>    <span class="comment">// Recover dx, dy</span></div>
<div class="line"><span class="lineno">  212</span>    dx = d.head(xi_d.size()); <span class="comment">// Gets the first n elements</span></div>
<div class="line"><span class="lineno">  213</span>    dy = d.tail(xi_p.size()); <span class="comment">// Gets the last m elements</span></div>
<div class="line"><span class="lineno">  214</span>    <span class="comment">// Recover dx</span></div>
<div class="line"><span class="lineno">  215</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  216</span>    Eigen::VectorXd d = 1.0 / (<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a9395e13c1709a243822be35d892e5a04">theta</a>.array() + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a966baa5cb12fdb5dc3ae2fe021e24069">regP</a>.array());</div>
<div class="line"><span class="lineno">  217</span>    <span class="comment">// Eigen::VectorXd xi_ = xi_p; // + ls.A * (d.asDiagonal() * xi_d);</span></div>
<div class="line"><span class="lineno">  218</span> </div>
<div class="line"><span class="lineno">  219</span>    <span class="comment">// print ls.A size</span></div>
<div class="line"><span class="lineno">  220</span>    Eigen::MatrixXd             dDense  = d.asDiagonal();</div>
<div class="line"><span class="lineno">  221</span>    Eigen::SparseMatrix&lt;double&gt; dSparse = dDense.sparseView();</div>
<div class="line"><span class="lineno">  222</span>    Eigen::SparseMatrix&lt;double&gt; AD(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a>.rows(), dSparse.cols());</div>
<div class="line"><span class="lineno">  223</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a>.outerSize(); ++k) {</div>
<div class="line"><span class="lineno">  224</span>        <span class="keywordflow">for</span> (Eigen::SparseMatrix&lt;double&gt;::InnerIterator it(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a>, k); it; ++it) {</div>
<div class="line"><span class="lineno">  225</span>            <span class="keywordtype">int</span> row = it.row();</div>
<div class="line"><span class="lineno">  226</span>            <span class="keywordtype">int</span> col = it.col();</div>
<div class="line"><span class="lineno">  227</span>            <span class="keywordflow">for</span> (Eigen::SparseMatrix&lt;double&gt;::InnerIterator jt(dSparse, col); jt; ++jt) {</div>
<div class="line"><span class="lineno">  228</span>                <span class="keywordtype">int</span> target_col = jt.col();</div>
<div class="line"><span class="lineno">  229</span>                AD.coeffRef(row, target_col) += it.value() * jt.value();</div>
<div class="line"><span class="lineno">  230</span>            }</div>
<div class="line"><span class="lineno">  231</span>        }</div>
<div class="line"><span class="lineno">  232</span>    }</div>
<div class="line"><span class="lineno">  233</span> </div>
<div class="line"><span class="lineno">  234</span>    Eigen::VectorXd xi_ = xi_p + AD * xi_d;</div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span>    <span class="comment">// Solve augmented system</span></div>
<div class="line"><span class="lineno">  237</span>    dy = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_function" href="classSparseSolver.html#a4337137c45bc2ff28f7e35baa5448417">solve</a>(xi_);</div>
<div class="line"><span class="lineno">  238</span> </div>
<div class="line"><span class="lineno">  239</span>    <span class="comment">// Recover dx</span></div>
<div class="line"><span class="lineno">  240</span>    dx = d.asDiagonal() * (<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a>.transpose() * dy - xi_d);</div>
<div class="line"><span class="lineno">  241</span>    <span class="comment">// Eigen::VectorXd ADy = ls.A.transpose() * dy; // AD will be of size A.cols() x 1</span></div>
<div class="line"><span class="lineno">  242</span>    <span class="comment">// Eigen::VectorXd ADxi_d = ADy - xi_d; // Assuming xi_d is already of size A.cols() x 1</span></div>
<div class="line"><span class="lineno">  243</span>    <span class="comment">// dx = d.asDiagonal() * ADxi_d; // dx will be of size A.cols() x 1</span></div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  246</span>}</div>
<div class="ttc" id="aclassSparseSolver_html_a4337137c45bc2ff28f7e35baa5448417"><div class="ttname"><a href="classSparseSolver.html#a4337137c45bc2ff28f7e35baa5448417">SparseSolver::solve</a></div><div class="ttdeci">Eigen::VectorXd solve(const Eigen::VectorXd &amp;rhs)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00220">IPSolver.h:220</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_a6c0451aa464e061c0611871d3e6842da"><div class="ttname"><a href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">SparseSolver::A</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; double &gt; A</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00182">IPSolver.h:182</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_a9395e13c1709a243822be35d892e5a04"><div class="ttname"><a href="classSparseSolver.html#a9395e13c1709a243822be35d892e5a04">SparseSolver::theta</a></div><div class="ttdeci">Eigen::VectorXd theta</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00179">IPSolver.h:179</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_a966baa5cb12fdb5dc3ae2fe021e24069"><div class="ttname"><a href="classSparseSolver.html#a966baa5cb12fdb5dc3ae2fe021e24069">SparseSolver::regP</a></div><div class="ttdeci">Eigen::VectorXd regP</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00180">IPSolver.h:180</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_a55c0e0acdfb28b73b2387a610bf8fbd6_cgraph.png" border="0" usemap="#aclassIPSolver_a55c0e0acdfb28b73b2387a610bf8fbd6_cgraph" alt=""/></div>
<map name="aclassIPSolver_a55c0e0acdfb28b73b2387a610bf8fbd6_cgraph" id="aclassIPSolver_a55c0e0acdfb28b73b2387a610bf8fbd6_cgraph">
<area shape="rect" title="Solves the augmented system for the given right&#45;hand side vectors." alt="" coords="5,5,185,46"/>
<area shape="rect" href="classSparseSolver.html#a4337137c45bc2ff28f7e35baa5448417" title=" " alt="" coords="233,13,369,38"/>
<area shape="poly" title=" " alt="" coords="185,23,217,23,217,28,185,28"/>
</map>
</div>

</div>
</div>
<a id="a10d79c906c9f170d975b9404e793a14e" name="a10d79c906c9f170d975b9404e793a14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d79c906c9f170d975b9404e793a14e">&#9670;&#160;</a></span>solve_augsys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::solve_augsys </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>theta_vw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;</td>          <td class="paramname"><span class="paramname"><em>ubi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_u</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00248">248</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  250</span>                                                                                                             {</div>
<div class="line"><span class="lineno">  251</span>    <span class="comment">// Create a modifiable copy of xi_d</span></div>
<div class="line"><span class="lineno">  252</span>    Eigen::VectorXd xi_d_mod = xi_d;</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>    <span class="comment">// Update the copy (xi_d_mod) instead of the original</span></div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi.size(); ++i) {</div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordtype">int</span> idx = ubi(i);                                  <span class="comment">// Cache the index</span></div>
<div class="line"><span class="lineno">  257</span>        xi_d_mod.coeffRef(idx) -= xi_u(idx) * theta_vw(i); <span class="comment">// Modify the copy</span></div>
<div class="line"><span class="lineno">  258</span>    }</div>
<div class="line"><span class="lineno">  259</span> </div>
<div class="line"><span class="lineno">  260</span>    <span class="comment">// Call the function to solve the augmented system</span></div>
<div class="line"><span class="lineno">  261</span>    <a class="code hl_function" href="#a55c0e0acdfb28b73b2387a610bf8fbd6">solve_augmented_system</a>(delta_x, delta_y, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, xi_p, xi_d_mod);</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span>    <span class="comment">// Update delta_z more efficiently with direct access</span></div>
<div class="line"><span class="lineno">  264</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi.size(); ++i) {</div>
<div class="line"><span class="lineno">  265</span>        <span class="keywordtype">int</span> idx    = ubi(i); <span class="comment">// Cache the index</span></div>
<div class="line"><span class="lineno">  266</span>        delta_z(i) = (delta_x(idx) - xi_u(i)) * theta_vw(i);</div>
<div class="line"><span class="lineno">  267</span>    }</div>
<div class="line"><span class="lineno">  268</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a55c0e0acdfb28b73b2387a610bf8fbd6"><div class="ttname"><a href="#a55c0e0acdfb28b73b2387a610bf8fbd6">IPSolver::solve_augmented_system</a></div><div class="ttdeci">void solve_augmented_system(Eigen::VectorXd &amp;dx, Eigen::VectorXd &amp;dy, SparseSolver &amp;ls, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d)</div><div class="ttdoc">Solves the augmented system for the given right-hand side vectors.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00201">IPSolver.cpp:201</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph.png" border="0" usemap="#aclassIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph" alt=""/></div>
<map name="aclassIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph" id="aclassIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,162,38"/>
<area shape="rect" href="classIPSolver.html#a55c0e0acdfb28b73b2387a610bf8fbd6" title="Solves the augmented system for the given right&#45;hand side vectors." alt="" coords="210,5,389,46"/>
<area shape="poly" title=" " alt="" coords="162,23,194,23,194,28,162,28"/>
<area shape="rect" href="classSparseSolver.html#a4337137c45bc2ff28f7e35baa5448417" title=" " alt="" coords="437,13,573,38"/>
<area shape="poly" title=" " alt="" coords="389,23,421,23,421,28,389,28"/>
</map>
</div>

</div>
</div>
<a id="ac225cc4dcfe81ae25d3d59bdcb0b029f" name="ac225cc4dcfe81ae25d3d59bdcb0b029f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">&#9670;&#160;</a></span>solve_newton_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::solve_newton_system </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_kappa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>theta_vw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;</td>          <td class="paramname"><span class="paramname"><em>ubi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ubv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta_0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>iter_tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>iter_kappa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>xi_g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_xs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_vw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>xi_tau_kappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Newton system for the interior point method. </p>
<p>This function updates the provided solution vectors (Delta_x, Delta_lambda, Delta_w, Delta_s, Delta_v) and scalars (Delta_tau, Delta_kappa) by solving the augmented system using the provided sparse solver. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00277">277</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  285</span>                                                                                 {</div>
<div class="line"><span class="lineno">  286</span>    Eigen::VectorXd xi_d_copy = xi_d - (xi_xs.array() / iter_x.array()).matrix();</div>
<div class="line"><span class="lineno">  287</span>    Eigen::VectorXd xi_u_copy = xi_u - (xi_vw.array() / iter_w.array()).matrix();</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span>    <span class="comment">// Call solve_augsys function here to update Delta_x, Delta_lambda, and</span></div>
<div class="line"><span class="lineno">  290</span>    <span class="comment">// Delta_w</span></div>
<div class="line"><span class="lineno">  291</span>    <a class="code hl_function" href="#a10d79c906c9f170d975b9404e793a14e">solve_augsys</a>(Delta_x, Delta_lambda, Delta_w, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, ubi, xi_p, xi_d_copy, xi_u_copy);</div>
<div class="line"><span class="lineno">  292</span> </div>
<div class="line"><span class="lineno">  293</span>    <span class="comment">// Avoid redundant calculations and simplify expressions where possible</span></div>
<div class="line"><span class="lineno">  294</span>    Delta_tau = (xi_g + (xi_tau_kappa / iter_tau) + c.dot(Delta_x) - b.dot(Delta_lambda) + ubv.dot(Delta_w)) / delta_0;</div>
<div class="line"><span class="lineno">  295</span>    Delta_kappa = (xi_tau_kappa - iter_kappa * Delta_tau) / iter_tau;</div>
<div class="line"><span class="lineno">  296</span> </div>
<div class="line"><span class="lineno">  297</span>    <span class="comment">// Use in-place operations to update Delta_x, Delta_lambda, and Delta_w</span></div>
<div class="line"><span class="lineno">  298</span>    Delta_x.array() += Delta_tau * delta_x.array();</div>
<div class="line"><span class="lineno">  299</span>    Delta_lambda.array() += Delta_tau * delta_y.array();</div>
<div class="line"><span class="lineno">  300</span>    Delta_w.array() += Delta_tau * delta_w.array();</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>    <span class="comment">// Simplify the Delta_s and Delta_v calculations</span></div>
<div class="line"><span class="lineno">  303</span>    Delta_s = (xi_xs.array() - iter_s.array() * Delta_x.array()).cwiseQuotient(iter_x.array());</div>
<div class="line"><span class="lineno">  304</span>    Delta_v = (xi_vw.array() - iter_v.array() * Delta_w.array()).cwiseQuotient(iter_w.array());</div>
<div class="line"><span class="lineno">  305</span>}</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph.png" border="0" usemap="#aclassIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph" alt=""/></div>
<map name="aclassIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph" id="aclassIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph">
<area shape="rect" title="Solves the Newton system for the interior point method." alt="" coords="5,5,163,46"/>
<area shape="rect" href="classIPSolver.html#a10d79c906c9f170d975b9404e793a14e" title=" " alt="" coords="211,13,367,38"/>
<area shape="poly" title=" " alt="" coords="163,23,195,23,195,28,163,28"/>
<area shape="rect" href="classIPSolver.html#a55c0e0acdfb28b73b2387a610bf8fbd6" title="Solves the augmented system for the given right&#45;hand side vectors." alt="" coords="415,5,594,46"/>
<area shape="poly" title=" " alt="" coords="367,23,399,23,399,28,367,28"/>
<area shape="rect" href="classSparseSolver.html#a4337137c45bc2ff28f7e35baa5448417" title=" " alt="" coords="642,13,779,38"/>
<area shape="poly" title=" " alt="" coords="595,23,627,23,627,28,595,28"/>
</map>
</div>

</div>
</div>
<a id="aac549fa9ef9fd8c98dc9262550a81f4d" name="aac549fa9ef9fd8c98dc9262550a81f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac549fa9ef9fd8c98dc9262550a81f4d">&#9670;&#160;</a></span>start_linear_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::start_linear_solver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the linear solver by initializing the necessary data structures and performing factorization. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00864">864</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  864</span>                                                                                      {</div>
<div class="line"><span class="lineno">  865</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a> = A;</div>
<div class="line"><span class="lineno">  866</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a> = A.rows();</div>
<div class="line"><span class="lineno">  867</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a> = A.cols();</div>
<div class="line"><span class="lineno">  868</span>    <span class="comment">// print ls.A size</span></div>
<div class="line"><span class="lineno">  869</span> </div>
<div class="line"><span class="lineno">  870</span><span class="preprocessor">#ifdef AUGMENTED</span></div>
<div class="line"><span class="lineno">  871</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a9395e13c1709a243822be35d892e5a04">theta</a> = Eigen::VectorXd::Ones(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a>);</div>
<div class="line"><span class="lineno">  872</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a966baa5cb12fdb5dc3ae2fe021e24069">regP</a>  = Eigen::VectorXd::Ones(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a>);</div>
<div class="line"><span class="lineno">  873</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a63e4283c6f918fe6ed49341ee5c4956e">regD</a>  = Eigen::VectorXd::Ones(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a>);</div>
<div class="line"><span class="lineno">  874</span> </div>
<div class="line"><span class="lineno">  875</span>    Eigen::SparseMatrix&lt;double&gt; topRight    = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a>.transpose();</div>
<div class="line"><span class="lineno">  876</span>    Eigen::SparseMatrix&lt;double&gt; bottomLeft  = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a>;</div>
<div class="line"><span class="lineno">  877</span>    Eigen::SparseMatrix&lt;double&gt; topLeft     = <a class="code hl_function" href="#ad6ab576c321bd6a0506d9c5bf8362f1a">convertToSparseDiagonal</a>(-<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a9395e13c1709a243822be35d892e5a04">theta</a> - <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a966baa5cb12fdb5dc3ae2fe021e24069">regP</a>);</div>
<div class="line"><span class="lineno">  878</span>    Eigen::SparseMatrix&lt;double&gt; bottomRight = <a class="code hl_function" href="#ad6ab576c321bd6a0506d9c5bf8362f1a">convertToSparseDiagonal</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a63e4283c6f918fe6ed49341ee5c4956e">regD</a>);</div>
<div class="line"><span class="lineno">  879</span> </div>
<div class="line"><span class="lineno">  880</span>    <span class="comment">// S_ is known, reserve space for it</span></div>
<div class="line"><span class="lineno">  881</span>    Eigen::SparseMatrix&lt;double&gt; S_(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a> + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a>, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a> + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a>);</div>
<div class="line"><span class="lineno">  882</span> </div>
<div class="line"><span class="lineno">  883</span>    <span class="comment">// Reserving space for tripletList</span></div>
<div class="line"><span class="lineno">  884</span>    <span class="keywordtype">int</span> estimated_nonzeros = topLeft.nonZeros() + 2 * topRight.nonZeros() + bottomRight.nonZeros();</div>
<div class="line"><span class="lineno">  885</span>    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; tripletList;</div>
<div class="line"><span class="lineno">  886</span>    tripletList.reserve(estimated_nonzeros);</div>
<div class="line"><span class="lineno">  887</span> </div>
<div class="line"><span class="lineno">  888</span>    <span class="comment">// Insert topLeft, topRight, bottomLeft, bottomRight matrices</span></div>
<div class="line"><span class="lineno">  889</span>    <span class="keyword">auto</span> insertBlock = [&amp;](<span class="keyword">const</span> Eigen::SparseMatrix&lt;double&gt; &amp;block, <span class="keywordtype">int</span> startRow, <span class="keywordtype">int</span> startCol) {</div>
<div class="line"><span class="lineno">  890</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; block.outerSize(); ++k) {</div>
<div class="line"><span class="lineno">  891</span>            <span class="keywordflow">for</span> (Eigen::SparseMatrix&lt;double&gt;::InnerIterator it(block, k); it; ++it) {</div>
<div class="line"><span class="lineno">  892</span>                tripletList.emplace_back(it.row() + startRow, it.col() + startCol, it.value());</div>
<div class="line"><span class="lineno">  893</span>            }</div>
<div class="line"><span class="lineno">  894</span>        }</div>
<div class="line"><span class="lineno">  895</span>    };</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span>    insertBlock(topLeft, 0, 0);</div>
<div class="line"><span class="lineno">  898</span>    insertBlock(topRight, 0, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a>);</div>
<div class="line"><span class="lineno">  899</span>    insertBlock(bottomLeft, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a>, 0);</div>
<div class="line"><span class="lineno">  900</span>    insertBlock(bottomRight, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a>, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a>);</div>
<div class="line"><span class="lineno">  901</span> </div>
<div class="line"><span class="lineno">  902</span>    <span class="comment">// Finally, set the values from the triplets</span></div>
<div class="line"><span class="lineno">  903</span>    S_.setFromTriplets(tripletList.begin(), tripletList.end());</div>
<div class="line"><span class="lineno">  904</span>    <span class="comment">// S_.makeCompressed();</span></div>
<div class="line"><span class="lineno">  905</span> </div>
<div class="line"><span class="lineno">  906</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a1d3220221a7ee978f99c6770eb1b4d8e">S</a> = S_;</div>
<div class="line"><span class="lineno">  907</span>    <span class="comment">// Factorize</span></div>
<div class="line"><span class="lineno">  908</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_function" href="classSparseSolver.html#aaeeba47cb827fd930578cd6d71a35272">factorizeMatrix</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a1d3220221a7ee978f99c6770eb1b4d8e">S</a>);</div>
<div class="line"><span class="lineno">  909</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  910</span>}</div>
<div class="ttc" id="aclassIPSolver_html_ad6ab576c321bd6a0506d9c5bf8362f1a"><div class="ttname"><a href="#ad6ab576c321bd6a0506d9c5bf8362f1a">IPSolver::convertToSparseDiagonal</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; double &gt; convertToSparseDiagonal(const Eigen::VectorXd &amp;vec)</div><div class="ttdoc">Converts a dense vector to a sparse diagonal matrix.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00022">IPSolver.cpp:22</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_a0ced5508f5ce97e7283461fb54925076"><div class="ttname"><a href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">SparseSolver::n</a></div><div class="ttdeci">int n</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00177">IPSolver.h:177</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_a1d3220221a7ee978f99c6770eb1b4d8e"><div class="ttname"><a href="classSparseSolver.html#a1d3220221a7ee978f99c6770eb1b4d8e">SparseSolver::S</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; double &gt; S</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00183">IPSolver.h:183</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_a63e4283c6f918fe6ed49341ee5c4956e"><div class="ttname"><a href="classSparseSolver.html#a63e4283c6f918fe6ed49341ee5c4956e">SparseSolver::regD</a></div><div class="ttdeci">Eigen::VectorXd regD</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00181">IPSolver.h:181</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_aaeeba47cb827fd930578cd6d71a35272"><div class="ttname"><a href="classSparseSolver.html#aaeeba47cb827fd930578cd6d71a35272">SparseSolver::factorizeMatrix</a></div><div class="ttdeci">void factorizeMatrix(const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int &gt; &amp;matrix)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00216">IPSolver.h:216</a></div></div>
<div class="ttc" id="aclassSparseSolver_html_ae1cfad5820b75edef371654b580f6050"><div class="ttname"><a href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">SparseSolver::m</a></div><div class="ttdeci">int m</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00178">IPSolver.h:178</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph.png" border="0" usemap="#aclassIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph" alt=""/></div>
<map name="aclassIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph" id="aclassIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph">
<area shape="rect" title=" " alt="" coords="5,35,147,75"/>
<area shape="rect" href="classIPSolver.html#ad6ab576c321bd6a0506d9c5bf8362f1a" title="Converts a dense vector to a sparse diagonal matrix." alt="" coords="201,5,378,46"/>
<area shape="poly" title=" " alt="" coords="147,43,186,37,186,43,147,48"/>
<area shape="rect" href="classSparseSolver.html#aaeeba47cb827fd930578cd6d71a35272" title=" " alt="" coords="195,70,384,96"/>
<area shape="poly" title=" " alt="" coords="147,62,179,66,179,71,147,67"/>
</map>
</div>

</div>
</div>
<a id="ab307fb2afd387146ea711f123caf12d6" name="ab307fb2afd387146ea711f123caf12d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab307fb2afd387146ea711f123caf12d6">&#9670;&#160;</a></span>update_linear_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::update_linear_solver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>regP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>regD</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00820">820</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  821</span>                                                               {</div>
<div class="line"><span class="lineno">  822</span>    <span class="comment">// Update internal data</span></div>
<div class="line"><span class="lineno">  823</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a9395e13c1709a243822be35d892e5a04">theta</a> = theta;</div>
<div class="line"><span class="lineno">  824</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a966baa5cb12fdb5dc3ae2fe021e24069">regP</a>  = regP;</div>
<div class="line"><span class="lineno">  825</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a63e4283c6f918fe6ed49341ee5c4956e">regD</a>  = regD;</div>
<div class="line"><span class="lineno">  826</span> </div>
<div class="line"><span class="lineno">  827</span><span class="preprocessor">#ifdef AUGMENTED</span></div>
<div class="line"><span class="lineno">  828</span>    <span class="comment">// Update S. S is stored as upper-triangular and only its diagonal changes.</span></div>
<div class="line"><span class="lineno">  829</span>    Eigen::VectorXd combinedValues(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a> + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a>);</div>
<div class="line"><span class="lineno">  830</span>    combinedValues.head(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a>) = -theta - regP;</div>
<div class="line"><span class="lineno">  831</span>    combinedValues.tail(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a>) = regD;</div>
<div class="line"><span class="lineno">  832</span> </div>
<div class="line"><span class="lineno">  833</span>    <span class="comment">// Efficiently update diagonal elements</span></div>
<div class="line"><span class="lineno">  834</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; combinedValues.size(); i++) { <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a1d3220221a7ee978f99c6770eb1b4d8e">S</a>.coeffRef(i, i) = combinedValues[i]; }</div>
<div class="line"><span class="lineno">  835</span> </div>
<div class="line"><span class="lineno">  836</span>    <span class="comment">// Refactorize</span></div>
<div class="line"><span class="lineno">  837</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_function" href="classSparseSolver.html#aaeeba47cb827fd930578cd6d71a35272">factorizeMatrix</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a1d3220221a7ee978f99c6770eb1b4d8e">S</a>);</div>
<div class="line"><span class="lineno">  838</span> </div>
<div class="line"><span class="lineno">  839</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  840</span> </div>
<div class="line"><span class="lineno">  841</span>    <span class="comment">// define lhs for normal equations</span></div>
<div class="line"><span class="lineno">  842</span>    Eigen::SparseMatrix&lt;double&gt; lhs(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a> + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a>, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a0ced5508f5ce97e7283461fb54925076">n</a> + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#ae1cfad5820b75edef371654b580f6050">m</a>);</div>
<div class="line"><span class="lineno">  843</span>    <span class="comment">// define lhs as   A (\Theta^{-1} + R_{p})^{-1} A^{\top} + R_{d}</span></div>
<div class="line"><span class="lineno">  844</span>    Eigen::VectorXd d = 1.0 / (<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a9395e13c1709a243822be35d892e5a04">theta</a>.array() + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a966baa5cb12fdb5dc3ae2fe021e24069">regP</a>.array());</div>
<div class="line"><span class="lineno">  845</span>    <span class="comment">// set rhs as \xi_{p} + A (^{-1} + R_{p})^{-1} \xi_{d}</span></div>
<div class="line"><span class="lineno">  846</span>    Eigen::MatrixXd             dDense  = d.asDiagonal();</div>
<div class="line"><span class="lineno">  847</span>    Eigen::SparseMatrix&lt;double&gt; dSparse = dDense.sparseView();</div>
<div class="line"><span class="lineno">  848</span> </div>
<div class="line"><span class="lineno">  849</span>    Eigen::MatrixXd             regDDense  = regD.asDiagonal();</div>
<div class="line"><span class="lineno">  850</span>    Eigen::SparseMatrix&lt;double&gt; regDSparse = regDDense.sparseView();</div>
<div class="line"><span class="lineno">  851</span>    Eigen::SparseMatrix&lt;double&gt; AD         = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a> * dSparse;</div>
<div class="line"><span class="lineno">  852</span>    Eigen::SparseMatrix&lt;double&gt; ADA        = AD * <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_variable" href="classSparseSolver.html#a6c0451aa464e061c0611871d3e6842da">A</a>.transpose();</div>
<div class="line"><span class="lineno">  853</span>    lhs                                    = ADA + regDSparse;</div>
<div class="line"><span class="lineno">  854</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.<a class="code hl_function" href="classSparseSolver.html#aaeeba47cb827fd930578cd6d71a35272">factorizeMatrix</a>(lhs);</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  857</span>}</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_ab307fb2afd387146ea711f123caf12d6_cgraph.png" border="0" usemap="#aclassIPSolver_ab307fb2afd387146ea711f123caf12d6_cgraph" alt=""/></div>
<map name="aclassIPSolver_ab307fb2afd387146ea711f123caf12d6_cgraph" id="aclassIPSolver_ab307fb2afd387146ea711f123caf12d6_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,160,46"/>
<area shape="rect" href="classSparseSolver.html#aaeeba47cb827fd930578cd6d71a35272" title=" " alt="" coords="208,13,397,38"/>
<area shape="poly" title=" " alt="" coords="160,23,192,23,192,28,160,28"/>
</map>
</div>

</div>
</div>
<a id="a2dcb29f3a4d1b424e4daa6921ba2b8e1" name="a2dcb29f3a4d1b424e4daa6921ba2b8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcb29f3a4d1b424e4daa6921ba2b8e1">&#9670;&#160;</a></span>update_residuals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::update_residuals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structResiduals.html">Residuals</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ubv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;</td>          <td class="paramname"><span class="paramname"><em>ubi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vbv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;</td>          <td class="paramname"><span class="paramname"><em>vbi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>kappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the residuals for the interior point method solver. </p>
<p>This function calculates and updates the primal residual (rp), upper bound residual (ru), dual residual (rd), and gap residual (rg) along with their norms. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00157">157</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  161</span>                                                                                                              {</div>
<div class="line"><span class="lineno">  162</span>    <span class="comment">// Efficiently calculate rp (primal residual) using noalias to avoid unnecessary allocations</span></div>
<div class="line"><span class="lineno">  163</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a3cb0e8ee76818efdbb792873e419332c">rp</a>.noalias() = <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * b - A * x;</div>
<div class="line"><span class="lineno">  164</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#abcda04c94a4b970be0ae54acf15ce002">rpn</a>          = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a3cb0e8ee76818efdbb792873e419332c">rp</a>.norm(); <span class="comment">// Primal residual norm</span></div>
<div class="line"><span class="lineno">  165</span> </div>
<div class="line"><span class="lineno">  166</span>    <span class="comment">// Calculate ru (upper bound residual) with fewer iterations by combining operations</span></div>
<div class="line"><span class="lineno">  167</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a70254a2a6c47d246447061780a337303">ru</a> = -v; <span class="comment">// Directly assign -v to res.ru</span></div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>    <span class="comment">// Update res.ru more efficiently using Eigen&#39;s indexed operations</span></div>
<div class="line"><span class="lineno">  170</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi.size(); ++i) {</div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordtype">int</span> idx = ubi(i); <span class="comment">// Cache index access</span></div>
<div class="line"><span class="lineno">  172</span>        <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a70254a2a6c47d246447061780a337303">ru</a>(idx) += <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * ubv(i) - x(idx);</div>
<div class="line"><span class="lineno">  173</span>    }</div>
<div class="line"><span class="lineno">  174</span> </div>
<div class="line"><span class="lineno">  175</span>    <span class="comment">// Efficiently calculate rd (dual residual) using noalias to avoid temporary allocations</span></div>
<div class="line"><span class="lineno">  176</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#ac370dbd3cdc8027a63a8907fd47356e8">rd</a>.noalias() = <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * c - A.transpose() * lambda - s;</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span>    <span class="comment">// Update res.rd similarly to ru, using Eigen&#39;s indexed access</span></div>
<div class="line"><span class="lineno">  179</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi.size(); ++i) {</div>
<div class="line"><span class="lineno">  180</span>        <span class="keywordtype">int</span> idx = ubi(i); <span class="comment">// Cache index access</span></div>
<div class="line"><span class="lineno">  181</span>        <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#ac370dbd3cdc8027a63a8907fd47356e8">rd</a>(idx) += w(i);</div>
<div class="line"><span class="lineno">  182</span>    }</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>    <span class="comment">// Efficiently calculate rg (gap residual) by combining dot products</span></div>
<div class="line"><span class="lineno">  185</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#aa99ffc1dacb947d10f9e886c3e9005ab">rg</a>  = <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> + c.dot(x) - b.dot(lambda) + ubv.dot(w);</div>
<div class="line"><span class="lineno">  186</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#a8ae9d6b59a77686acb8d7b8f3810ca93">rgn</a> = std::abs(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.<a class="code hl_variable" href="structResiduals.html#aa99ffc1dacb947d10f9e886c3e9005ab">rg</a>); <span class="comment">// Since rg is scalar, its &quot;norm&quot; is just the absolute value</span></div>
<div class="line"><span class="lineno">  187</span>}</div>
<div class="ttc" id="astructResiduals_html_a8ae9d6b59a77686acb8d7b8f3810ca93"><div class="ttname"><a href="structResiduals.html#a8ae9d6b59a77686acb8d7b8f3810ca93">Residuals::rgn</a></div><div class="ttdeci">double rgn</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00065">IPSolver.h:65</a></div></div>
<div class="ttc" id="astructResiduals_html_abcda04c94a4b970be0ae54acf15ce002"><div class="ttname"><a href="structResiduals.html#abcda04c94a4b970be0ae54acf15ce002">Residuals::rpn</a></div><div class="ttdeci">double rpn</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00065">IPSolver.h:65</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b689456be5e57ddcadae9254dc35c4a" name="a8b689456be5e57ddcadae9254dc35c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b689456be5e57ddcadae9254dc35c4a">&#9670;&#160;</a></span>dual_vals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IPSolver::dual_vals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00272">272</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a981ecfeb17af8eebcb536c8ec5075e28" name="a981ecfeb17af8eebcb536c8ec5075e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981ecfeb17af8eebcb536c8ec5075e28">&#9670;&#160;</a></span>infty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::infty = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00258">258</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a957045b153c2587ced811544b5772410" name="a957045b153c2587ced811544b5772410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957045b153c2587ced811544b5772410">&#9670;&#160;</a></span>kappa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::kappa</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00256">256</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="afc64d7bec3101a6366409c58206d976d" name="afc64d7bec3101a6366409c58206d976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc64d7bec3101a6366409c58206d976d">&#9670;&#160;</a></span>kappa_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::kappa_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00267">267</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ade64d46c893afea62c9c761d8c93991d" name="ade64d46c893afea62c9c761d8c93991d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade64d46c893afea62c9c761d8c93991d">&#9670;&#160;</a></span>lambda_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::lambda_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00262">262</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a5c55da355d90e490435337a5427b3c0c" name="a5c55da355d90e490435337a5427b3c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55da355d90e490435337a5427b3c0c">&#9670;&#160;</a></span>ls</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseSolver.html">SparseSolver</a> IPSolver::ls</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00255">255</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ad0c2594ea4f46d9be99f18a27b34a7d8" name="ad0c2594ea4f46d9be99f18a27b34a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c2594ea4f46d9be99f18a27b34a7d8">&#9670;&#160;</a></span>max_iter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPSolver::max_iter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00257">257</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a4c6e2a7694ec8befa9470e1aa4acf438" name="a4c6e2a7694ec8befa9470e1aa4acf438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6e2a7694ec8befa9470e1aa4acf438">&#9670;&#160;</a></span>n_slacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPSolver::n_slacks = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00269">269</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="af1d4563c64b404dc1c6a973f9b899508" name="af1d4563c64b404dc1c6a973f9b899508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d4563c64b404dc1c6a973f9b899508">&#9670;&#160;</a></span>n_slacks_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPSolver::n_slacks_old = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00268">268</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a46689efc5c499d0e9b53b661e0a5405e" name="a46689efc5c499d0e9b53b661e0a5405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46689efc5c499d0e9b53b661e0a5405e">&#9670;&#160;</a></span>objVal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::objVal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00274">274</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a77a138d4376f21d730e110d0547af83b" name="a77a138d4376f21d730e110d0547af83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a138d4376f21d730e110d0547af83b">&#9670;&#160;</a></span>primal_vals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IPSolver::primal_vals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00273">273</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="af3536735b8f4efc21e11a83b8062f5f2" name="af3536735b8f4efc21e11a83b8062f5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3536735b8f4efc21e11a83b8062f5f2">&#9670;&#160;</a></span>res</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structResiduals.html">Residuals</a> IPSolver::res</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00254">254</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ac9a3f9beb44ee2ba28b0d5cc8ea6edfb" name="ac9a3f9beb44ee2ba28b0d5cc8ea6edfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a3f9beb44ee2ba28b0d5cc8ea6edfb">&#9670;&#160;</a></span>s_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::s_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00263">263</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a54987d081f0eebc91d6a0247c471d92a" name="a54987d081f0eebc91d6a0247c471d92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54987d081f0eebc91d6a0247c471d92a">&#9670;&#160;</a></span>tau</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::tau</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00256">256</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a60db34cbbec5a679411c8ec9d25f2dcd" name="a60db34cbbec5a679411c8ec9d25f2dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60db34cbbec5a679411c8ec9d25f2dcd">&#9670;&#160;</a></span>tau_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::tau_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00266">266</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ac1a5e7d41b0f72ce616f99b03d4785a5" name="ac1a5e7d41b0f72ce616f99b03d4785a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a5e7d41b0f72ce616f99b03d4785a5">&#9670;&#160;</a></span>tol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::tol</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00256">256</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ab34388a63283d1d26ccd9b77f879c16b" name="ab34388a63283d1d26ccd9b77f879c16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34388a63283d1d26ccd9b77f879c16b">&#9670;&#160;</a></span>v_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::v_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00264">264</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a31f8ae7257d8a77f3caa63b3de21588c" name="a31f8ae7257d8a77f3caa63b3de21588c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f8ae7257d8a77f3caa63b3de21588c">&#9670;&#160;</a></span>w_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::w_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00265">265</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a6b9b941d7216d239af63eede001ab647" name="a6b9b941d7216d239af63eede001ab647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9b941d7216d239af63eede001ab647">&#9670;&#160;</a></span>warm_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPSolver::warm_start = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00270">270</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a120a3a2e1d4aa282ef28da6ca378d7bc" name="a120a3a2e1d4aa282ef28da6ca378d7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120a3a2e1d4aa282ef28da6ca378d7bc">&#9670;&#160;</a></span>x_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::x_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00261">261</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="IPSolver_8h_source.html">IPSolver.h</a></li>
<li><a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classIPSolver.html">IPSolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
